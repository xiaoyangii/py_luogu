window._feInjection = JSON.parse(decodeURIComponent("{"code":200,"currentTemplate":"ProblemSolution","currentData":{"solutions":{"result":[{"content":"```

\/\/记录每一句话是谁说的以及这句话的内容
\/\/可以用map存人名对应的下标 

\/\/我们枚举每一个人i，假设i是罪犯
\/\/然后枚举今天是星期几，用day表示 
\/\/然后判断有没有矛盾

\/\/如何判断？
\/\/进行每一次判断的时候，先使所有人的状态不确定，也就是不知道他们会说真话假话
\/\/TF[a]==-1是不确定，TF[a]=1是说真话，TF[a]=0是说假话
\/\/T是说真话的人数，F是说假话的人数 
\/\/设罪犯为 i 
\/\/设flag为这句话是真话还是假话，flag=1是真话，flag=0是假话 
\/\/id是说这句话的人 
\/\/枚举每一句话
\/\/	看一下id以前的状态，如果状态不确定（TF==-1），就TF[id]=flag
\/\/	否则，如果和以前状态一样(TF[id]==flag)，就没有矛盾，
\/\/	TF[id]!=flag就是出现了矛盾(因为一个人始终直说一种话)，判断不出来了，直接return去枚举下一个人是罪犯 
\/\/如果F>n或者T>m-n了，也就是说假话的人数超过了题目中给的人数，矛盾，return
\/\/如果找到了不止一个罪犯，输出"Cannot Determine"，直接exit(0) 

\/\/怎么知道这句话是真话假话？ 
\/\/①如果话里有 "I am guilty."
\/\/	那么看一下id是不是i，不是的话，就是在说假话
\/\/②话里有"I am not guilty"
\/\/	看一下id是不是i，不是的话，就是在说真话，否则就是假话 
\/\/③话里有"xxx is guilty"
\/\/	如果xxx是i的话，就是真话，否则是假话
\/\/④话里有"xxx is not guilty"
\/\/	如果xxx不是i的话，就是真话，否则是假话
\/\/⑤话里有"Today is XXX"
\/\/	如果xxx与day一样，就是真话，否则是假话
 
#include
#include
#include
#include
#include
using namespace std;

string S[10]=
{
	"Today is Sunday.",
	"Today is Monday.",
	"Today is Tuesday.",
	"Today is Wednesday.",
	"Today is Thursday.",
	"Today is Friday.",
	"Today is Saturday.",
};

int m,n,p;
int T,F,ans;
int TF[25];
struct Sen
{
	int id;
	string s;
}sen[105];
map ma;

bool judgeTF(int id,bool flag)	\/\/看一下有没有冲突，return 1 表示有冲突 
{
	if(TF[id]==-1)		\/\/状态不确定 
	{
		TF[id]=flag;	\/\/赋状态 
		if(flag)	\/\/说真话的人数++ 
			++T;
		else	\/\/说假话的人数++ 
			++F;
	}
	else
		return TF[id]!=flag;	\/\/和之前的一不一样，一样返回0，不一样返回1 
	if(F>n||T>m-n)	\/\/说假话的人比n多或者是说真话的人比m-n多 
		return 1;
	return 0;
}

void judge(int id,string day)
{
	memset(TF,-1,sizeof(TF));	\/\/所有人都不知道说的是真话假话 
	T=F=0;		\/\/说真话、假话人数置0 
	string tmp;
	for(int i=1;i<=p;++i)
	{
		int pos=sen[i].s.find("I am guilty.");	\/\/pos为-1则没说这句话 
		if(~pos)
		{
			if(judgeTF(sen[i].id,sen[i].id==id))	\/\/因为我们假设了id是罪犯，所以不是id的人就不是罪犯，就是在说假话
				return;
		}
		pos=sen[i].s.find("I am not guilty");
		if(~pos)
		{
			if(judgeTF(sen[i].id,sen[i].id!=id))
				return;
		}
		pos=sen[i].s.find(" is guilty.");
		if(~pos)
		{
			tmp=sen[i].s;
			tmp.erase(pos,11);
			if(judgeTF(sen[i].id,ma[tmp]==id))
				return;
		}
		pos=sen[i].s.find(" is not guilty.");
		if(~pos)
		{
			tmp=sen[i].s;
			tmp.erase(pos,15);
			if(judgeTF(sen[i].id,ma[tmp]!=id))
				return;
		}
		pos=sen[i].s.find("Today is ");
		if(~pos)
		{
			if(judgeTF(sen[i].id,sen[i].s==day))
				return;
		}
	}
	if(ans&&ans!=id)	\/\/找到了不止一个罪犯 
	{
		puts("Cannot Determine");	\/\/不能确定 
		exit(0);
	}
	ans=id;		\/\/id是罪犯 
}

string s[25],name,a;
int main()
{
	scanf("%d%d%d",&m,&n,&p);
	for(int i=1;i<=m;++i)
	{
		cin>>s[i];
		ma[s[i]]=i;		\/\/存名字标号 
	}
	for(int i=1;i<=p;++i)
	{
		cin>>name;		\/\/输入说话者 
		name.erase(name.length()-1,1);		\/\/把后边的冒号搞掉 
		getline(cin,a);
		a.erase(0,1);	\/\/把前边的空格搞掉 
		if(a[a.length()-1]=='\n'||a[a.length()-1]=='\r')	\/\/把坑爹的换行符搞掉 
			a.erase(a.length()-1,1);
		sen[i].id=ma[name];		\/\/存说话者 
		sen[i].s=a;		\/\/存说话内容 
	}
	for(int i=1;i<=m;++i)	\/\/假设第i个人是罪犯 
		for(int j=0;j<7;++j)	\/\/假设今天是S[j]天 
			judge(i,S[j]);
	if(!ans)	\/\/找不到罪犯 
		puts("Impossible");
	else
		cout<<s[ans];	\/\/罪犯名字 
	return 0;
}
```","type":"题解","status":2,"postTime":1522237544,"author":{"uid":39886,"name":"Drifterming","slogan":"这个家伙很勤，留下了一句个签。","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":""},"thumbUp":52,"commentCount":21,"currentUserVoteType":0,"contentDescription":"","id":32826,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"注意换行符！！！


注意换行符！！！


注意换行符！！！


如果你使用getchar()系列函数读入，并且用换行符判定是否结束，则换行符会导致你WA掉！


linux下换行符为'\n'，windows下换行符为'\r\n'，如果数据是windows下造的，你就把'\r'也给当成字符串内容了，不wa才怪。


所以，你可以选择建立一个缓存区，把所有的'\r'替换成'\n'，进行计算。


读取一整行的方法：

```cpp
fgets(char* dst,size_t buf_size,File* file) 
```
最后一个参数传stdin即可。不要用scanf("%[^\n]",str)，因为你不知道最后的换行符是啥！


另外为了预防文末没换行的情况，手动在缓存区末补上一个'\n'。


具体算法不多说了，先预处理出每个人表示的意思，然后二进制状压枚举撒谎的人，如果这个状态的大小与所给人数相同，则进行计算。记得判定矛盾。可能这个状态是互相矛盾的，则不应更新答案。


如果输入存在矛盾，直接输出impossible。


如果一个状态有多个人未知，且没有人必定为罪犯则多解。


如果多个状态推出不同的罪犯，则多解。


如果一个状态只有一个人未知，其余的人都一定不是罪犯，则用这个不确定的人是罪犯去更新答案。


最后数一下有多少个人可能是罪犯，统计size，如果size为0则输出impossible，为1则输出人名，其余情况输出多解。


——Cmd2001 @ 2017.10.19


最后上代码：


```cpp
#include
#define debug cout
using namespace std;
const int maxn=30;
string name[maxn];
int ptr[maxn][maxn]; \/\/ 1 means is , -1 means not;
int day[maxn]; \/\/ means says day.
int day_can_be[maxn]; \/\/ can be that day ? 1 means is , -1 means is not.
int gul_can_be[maxn]; \/\/ persob i can be guilty or not , 1 means is , -1 means is not;
int may_be_ans[maxn]; \/\/ 0,1 means can be answer or not
string buf[1<<10];
map person;
int n,m,p,mx,cnt,ans;
inline int getdate(string x)
{
    if(x=="monday.") return 1;
    if(x=="tuesday.") return 2;
    if(x=="wednesday.") return 3;
    if(x=="thursday.") return 4;
    if(x=="friday.") return 5;
    if(x=="saturday.") return 6;
    if(x=="sunday.") return 7;
    return puts("Wrong spelling ! Fuck you!"),-1;
}
inline char convchar(char x)
{
    if( x>='A' && x<='Z' )
        return x-'A'+'a';
    else return x;
}
inline void convstring(string &x)
{
    for(unsigned i=0;i<x.length();i++)
        x[i] = convchar(x[i]);
}
inline char nextchar(int arg=0)
{
    static char buf[1<<10],*st;
    if(arg)
    {
        fgets(buf,1<<10,stdin),st=buf;
        int i;
        for(i=0;i<1<<10&&buf[i];i++)
            if( buf[i]=='\r' )
                buf[i] = '\n';
        buf[i] = '\n';
    }
    return *st++;
}
inline void getline()
{
    cnt = 0;
    char c=nextchar(1);
    cnt = 1;
    while( c != '\n' )
    {
        if(c==' ')
        {
            if( person.find(buf[cnt]) == person.end() )
                convstring(buf[cnt]);
            cnt++;
        }
        else
            buf[cnt] = buf[cnt] + c;
        c = nextchar();
    }
    while( buf[cnt]=="" ) cnt--;
    convstring(buf[cnt]);
}
inline void resbuf()
{
    for(int i=1;i<=cnt;i++)
        buf[i].clear(),
        buf[i].resize(0);
}
inline void explain()
{
    if( buf[2]!="i" && buf[2]!="today" && person.find(buf[2])==person.end() ) return;
    const int id = person[buf[1]];
    if( buf[2]=="today" )
    {
        int dd = getdate(buf[4]);
        if( day[id] && day[id]!=dd )
        {
            ans = -2;
            return;
        }
        day[id] = dd;
    }
    else if( buf[4]=="guilty." )
    {
        int tar = buf[2]=="i" ? id : person[buf[2]];
        if( ptr[id][tar] && ptr[id][tar]!=1 )
        {
            ans = -2;
            return;
        }
        ptr[id][tar] = 1;
    }
    else if( buf[5]=="guilty." )
    {
        int tar = buf[2]=="i" ? id : person[buf[2]];
        if( ptr[id][tar] && ptr[id][tar]!=-1 )
        {
            ans = -2;
            return;
        }
        ptr[id][tar] = -1;
    }
}
inline void reslogic()
{
    memset(day_can_be,0,sizeof(day_can_be));
    memset(gul_can_be,0,sizeof(gul_can_be));
}
inline void logic(int x,int mul,int& flag)
{
    if(day[x])
    {
        if( day_can_be[day[x]] && day_can_be[day[x]]!=mul )
        {
            flag=0;
            return;
        }
        day_can_be[day[x]] = mul;
    }
    for(int i=1;i<=n;i++)
        if(ptr[x][i])
        {
            const int pp = ptr[x][i]*mul;
            if( gul_can_be[i] && gul_can_be[i]!=pp )
            {
                flag = 0;
                return;
            }
            gul_can_be[i] = pp;
        }
}
inline bool judgedate()
{
    int ret=0;
    for(int i=1;i<=7;i++)
        if( ~day_can_be[i] )
            ret += day_can_be[i];
    return ret<2;
}
inline void judgegul()
{
    int pos = -1,siz=n;
    for(int i=1;i<=n;i++)
    {
        if( !~gul_can_be[i] ) --siz;
        else if( gul_can_be[i] == 1 )
        {
            pos = i;
            break;
        }
    }
    if( siz>1 && !~pos ) \/\/ can not determine , maybe multi guilty .
    {
        ans = -1;
        return;
    }
    if( siz==1 && !~pos )
        for(int i=1;i<=n;i++)
            if( !gul_can_be[i] )
            {
                may_be_ans[i] = 1;
                return;
            }
    for(int i=1;i<=n;i++)
        if( i!=pos && gul_can_be[i] == 1 ) \/\/ must be multi guilty in this statement
            return;
    may_be_ans[pos] = 1;
}
inline int count(int x)
{
    int ret=0;
    while(x)
        ret++,
        x -= (x&-x);
    return ret;
}
inline int getans()
{
    int ret = 0;
    for(int i=1;i<=n;i++)
        if( may_be_ans[i] )
        ret++,
        ans = i;
    return ret;
}
int main()
{
    scanf("%d%d%d",&n,&m,&p);
    mx = (1<<n);
    for(int i=1;i<=n;i++)
    {
        cin>>name[i];
        person[name[i]] = person[name[i]+":"] = i;
    }
    char c = nextchar(1);
    while(c!='\n') c=nextchar();
    for(int i=1;i<=p;i++)
    {
        resbuf();
        getline();
        explain();
    }
    if( ans == -2 )
        return puts("Impossible"),0;
    for(int s=0;s<mx;s++)
    {
        if( count(s) != m ) continue;
        reslogic();
        int flag =1;
        for(int i=1;i<=n&&flag;i++)
            if( s & (1<<(i-1)) )
                logic(i,-1,flag);
            else logic(i,1,flag);
        if( flag && judgedate() )
            judgegul();
    }
    if( !~ans )
        return puts("Cannot Determine"),0;
    if( !getans() )
        return puts("Impossible"),0;
    if( getans() > 1 )
        return puts("Cannot Determine"),0;
    cout<<name[ans]<<endl;
    return 0;
}
```","type":"题解","status":2,"postTime":1508585098,"author":{"uid":31907,"name":"cmd2001","slogan":"rm -rf ~","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":9,"background":""},"thumbUp":18,"commentCount":34,"currentUserVoteType":0,"contentDescription":"注意换行符！！！
注意换行符！！！
注意换行符！！！
如果你使用getchar()系列函数读入，并且用换行符判定是否结束，则换行符会导致你WA掉！
linux下换行符为'\n'，windows下...","id":1691,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"1、根据题意可知可以利用枚举法完成。枚举罪犯和今天是星期几。满足N个人始终说谎话和M-N个人始终说真话的条件，就可以确定罪犯。

2、首先利用字符串操作将证言转化成计算机可表示的信息。

1）定义

Guilty:Array[1..MM,1..MM] Of Integer;{-1..1} 

FillChar(Guilty,SizeOf(Guilty),0) 

初值为0 

 Guilty[i,j]=-1：表示第i个人说第j个人不是罪犯

Guilty[i,j]= 1：表示第i个人说第j个人是罪犯

其中包含Guilty[i,i]即第i个人说自己是不是罪犯 

注意：Guilty不可以自相矛盾。

2）定义

WhatDay:Array[1..MM,1..7] Of Boolean; 

FillChar(WhatDay,SizeOf(WhatDay),False) 

WhatDay[i,j]:=True  :表示第i个人说过j是星期几 

3、枚举罪犯和星期几，判断每句证言是真是假，统计说真假证言的人数。

注意：有可能某人又说过真话，又说过假话。

4、根据题目要求输出罪犯编号或Cannot Determine或Impossible。

","type":"题解","status":2,"postTime":1555372613,"author":{"uid":186489,"name":"EarthGiao","slogan":"acioi","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/ih20iv2t.png"},"thumbUp":13,"commentCount":9,"currentUserVoteType":0,"contentDescription":"1、根据题意可知可以利用枚举法完成。枚举罪犯和今天是星期几。满足N个人始终说谎话和M-N个人始终说真话的条件，就可以确定罪犯。
2、首先利用字符串操作将证言转化成计算机可表示的信息。
1）定义
...","id":126118,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"**我的博客：[传送门](https:\/\/www.wjyyy.top\/2305.html)**

## 题解：

这个题数据范围比较小，考虑枚举，但是枚举谁说真话谁说假话也比较耗时，但是我们发现日期只有一天，罪犯也只有一个，考虑枚举罪犯是谁，和今天是星期几。

在读入每一句话时，把这一句的主人（即冒号前的人）对应到它的编号，这里推荐使用`std::map`，然后判断种类，如果语句不合法就不读这句话，并用`gets()`把这一行读完进入下一句。如果发现第一个单词是人名，则用`std::map`找到它的编号，然后看它是**肯定句**还是**否定句**。对于每一个点开一个`vector`用来存它说过的**合法**的话，区分一下这句话是说人的信息还是日期，如果说人的信息还需要对应到对象，这里最好把`I`转化为自己的名字。

接着就可以枚举罪犯和日期了，因为有的人自始至终都没有说过一句合法的话，这样的人既可能说真话也可能说假话，我们用一个变量$ran$来存有多少个这样的人，剩下的人根据它第一句话来确定它是说真话还是说假话。如果一个人前后矛盾，即前面说真话后面说假话，那么这次枚举就不合法，可以直接跳到下次枚举去。

在一次成功的枚举中，我们得知了有多少人说假话，有多少人不确定，假设说假话的人有$cnt$个，并有$ran$个人不确定，那么当要求说假话的人数在$[cnt,cnt+ran]$范围内就合法。

如果一个罪犯被多次确定，是不会对答案造成额外影响的，但是当确定一个罪犯时发现前面已经确定一个人了，此时就要输出`Cannot Determine`了。当程序结束时还没有找到一个罪犯，则输出`Impossible`。找到罪犯了输出名字即可。

`stl`还是非常方便的，`std::string`用来存名字并进行字符串处理；`std::map`用来映射人名；`std::vector`用来存每个人说的话。不过这个题有一个比较坑的地方，必须要确定一个人说的一句话**每个单词**都合法后，才能把这整句话当作合法的。`&&`一定要注意单词后面的冒号和句号！

## Code：
以前以为码量很大，但是只要注意细节，条理清晰，$\sout{130}$~~行~~是很容易写出来的。

```cpp
#include
#include
#include
#include
using namespace std;
map per;\/\/存人名
string nm[25];
map day;\/\/映射日期
struct sta
{
    int u;\/\/u表示主语
    bool to;\/\/0表示罪犯，1表示日期
    bool is;\/\/表示肯定或否定
    sta(int u,bool to,bool is)
    {
        this->u=u;
        this->to=to;
        this->is=is;
    }
    sta(){}
};
vector v[25];
char asdfghjkl[1000];\/\/用来读废掉的语句
int main()
{
    int n,m,p;
    cin>>n>>m>>p;
    string s;
    for(int i=1;i<=n;++i)
    {
        cin>>s;
        per[s]=i;
        nm[i]=s;
    }
    per["Today"]=n+1;
    day["Monday."]=1;\/\/句号是因为答案
    day["Tuesday."]=2;
    day["Wednesday."]=3;
    day["Thursday."]=4;
    day["Friday."]=5;
    day["Saturday."]=6;
    day["Sunday."]=7;
    for(int i=1;i<=p;++i)
    {
        cin>>s;
        s=s.substr(0,s.size()-1);\/\/自动去掉
        int t=per[s];
        cin>>s;
        int u=per[s];
        if(u<=n)\/\/表示人名
        {
            cin>>s;
            if((u&&s!="is")||(!u&&s!="am"))
            {
                gets(asdfghjkl);
                continue;
            }
            if(!u)
                u=t;
            cin>>s;
            if(s=="not")
            {
                cin>>s;
                if(s=="guilty.")
                    v[t].push_back(sta(u,0,0));
            }
            else if(s=="guilty.")
                v[t].push_back(sta(u,0,1));
        }
        else if(u==n+1)\/\/表示日期
        {
            cin>>s;
            if(s!="is")
                continue;
            cin>>s;
            if(day[s])
                v[t].push_back(sta(day[s],1,1));
        }
        else
            gets(asdfghjkl);
    }
    string ans="";
    \/\/枚举谁是罪犯
    for(int i=1;i<=n;++i)
    {
        \/\/枚举今天星期几
        for(int j=1;j<=7;++j)
        {
            int flag=0,cnt=n,ran=0;\/\/ran表示波动范围
            for(int k=1;!flag&&k<=n;++k)
            {
                vector::iterator it=v[k].begin();
                if(!v[k].size())
                {
                    ++ran;
                    continue;
                }
                sta tmp=*it;
                bool rea;
                if(tmp.to)
                    rea=(tmp.u==j);
                else
                    rea=((tmp.u==i)^(!tmp.is));
                ++it;
                for(;!flag&&it!=v[k].end();++it)
                {
                    if(it->to)
                    {
                        if(rea!=(it->u==j))
                            flag=1;
                    }
                    else
                    {
                        if(rea==((it->u==i)^it->is))
                            flag=1;
                    }
                }
                cnt-=rea;
            }
            if(!flag&&cnt>=m&&cnt-ran<=m)
            {
                if(ans=="")
                    ans=nm[i];
                else if(ans!=nm[i])
                {
                    cout<<"Cannot Determine"<<endl;
                    return 0;
                }
            }
        }
    }
    if(ans=="")
        cout<<"Impossible"<<endl;
    else
        cout<<ans<<endl;
    return 0;
}
```","type":"题解","status":2,"postTime":1546426205,"author":{"uid":63539,"name":"wjyyy","slogan":"不能因为太阳光芒万丈而不敢仰望。","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":9,"background":""},"thumbUp":11,"commentCount":2,"currentUserVoteType":0,"contentDescription":"我的博客：传送门
题解：
这个题数据范围比较小，考虑枚举，但是枚举谁说真话谁说假话也比较耗时，但是我们发现日期只有一天，罪犯也只有一个，考虑枚举罪犯是谁，和今天是星期几。
在读入每一句话时，把这...","id":100948,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"#大家不要被体面吓到，其实这题不算很难

##总体思路

首先是读入，我采用了一个二维数组来保存证言，第一维是人名，第二维表示此人说的第几句话。接下来我们进行枚举，第一重循环枚举人名（1~m），第二重循环枚举星期几（1~7）。对于每一次枚举，我们进行两次判断：第一个判断是判断是否有人既说了真话又说了假话（题目中有谈到说一个人要么全部说真话，要么全部说假话），出现了这种情况可以直接说明枚举条件不成立；第二个判断是判断说假话的人数是否为n个。如果以上两个判断都成立，则可以认定这个枚举条件是一个解。

##细节

- 读入

我在这里被坑死了，也许是我菜吧，getline、gets、getchar居然全部出了莫名错误。好吧，我最后选择了cin，将证言一个一个单词读入，遇到标点符号则退出。具体参见gl函数。

- 废话的处理

因为有些人会说废话，而这些废话没有任何实际意义，故我们应该舍弃废话。我写了一个crap函数，判断是否为废话，这个函数代码清晰明了，请自行阅读。如果是废话则直接摒弃。

- 判断一

我上面说到的判断一体现在我代码里的judge函数中。枚举人名，每遇到一句假话，ans++，我们会发现，ans==0表示此人全说真话，ans==此人总共说的话表示此人全部说假话。假如ans==其它数，则直接认为与题设冲突，枚举条件不成立。

- 判断二

我上面说到的判断二体现在我代码里的check函数中。枚举人名，遇到假话，则说假话的人数++，然后直接break出去判断下一个人。如果说假话的人数==n,则枚举条件成立。这里有个细节，就是要考虑没说话的人，这个细节的处理方法可以看一下我的代码。


##奉上C++代码：









```cpp
#include
#include
#include
#include
using namespace std;
map name;
string s,ss;
string names[25];
string testimony[25][105];
int num[25];
int n,m,p;
bool crap(string tmp)
{
    if(tmp==" I am guilty.") return 0;
    if(tmp==" I am not guilty.") return 0;
    if(tmp==" Today is Monday.") return 0;
    if(tmp==" Today is Tuesday.") return 0;
    if(tmp==" Today is Wednesday.") return 0;
    if(tmp==" Today is Thursday.") return 0;
    if(tmp==" Today is Friday.") return 0;
    if(tmp==" Today is Saturday.") return 0;
    if(tmp==" Today is Sunday.") return 0;
    for(int i=1;i<=m;i++)
        if(tmp==" "+names[i]+" is guilty."||tmp==" "+names[i]+" is not guilty.") return 0;
    return 1;
}
bool judge(int guilty,int day)
{
    int ans;
    for(int i=1;i<=m;i++)
    {
        ans=0;
        for(int j=1;j<=num[i];j++)
        {
            if(testimony[i][j]==" I am guilty."&&guilty!=i) {ans++;}
            if(testimony[i][j]==" I am not guilty."&&guilty==i) {ans++;}
            if(testimony[i][j]==" Today is Monday."&&day!=1) {ans++;}
            if(testimony[i][j]==" Today is Tuesday."&&day!=2) {ans++;}
            if(testimony[i][j]==" Today is Wednesday."&&day!=3) {ans++;}
            if(testimony[i][j]==" Today is Thursday."&&day!=4) {ans++;}
            if(testimony[i][j]==" Today is Friday."&&day!=5) {ans++;}
            if(testimony[i][j]==" Today is Saturday."&&day!=6) {ans++;}
            if(testimony[i][j]==" Today is Sunday."&&day!=7) {ans++;}
            for(int k=1;k<=m;k++)
            {
                if(testimony[i][j]==" "+names[k]+" is guilty."&&guilty!=k) {ans++;}
                if(testimony[i][j]==" "+names[k]+" is not guilty."&&guilty==k) {ans++;}
            }
        }
        if(ans!=num[i]&&ans!=0) return 0;
    }
    return 1;
}
int check(int guilty,int day)
{
    int ans=0;
    bool twice;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=num[i];j++)
        {
            twice=0;
            if(testimony[i][j]==" I am guilty."&&guilty!=i) {ans++;break;}
            if(testimony[i][j]==" I am not guilty."&&guilty==i) {ans++;break;}
            if(testimony[i][j]==" Today is Monday."&&day!=1) {ans++;break;}
            if(testimony[i][j]==" Today is Tuesday."&&day!=2) {ans++;break;}
            if(testimony[i][j]==" Today is Wednesday."&&day!=3) {ans++;break;}
            if(testimony[i][j]==" Today is Thursday."&&day!=4) {ans++;break;}
            if(testimony[i][j]==" Today is Friday."&&day!=5) {ans++;break;}
            if(testimony[i][j]==" Today is Saturday."&&day!=6) {ans++;break;}
            if(testimony[i][j]==" Today is Sunday."&&day!=7) {ans++;break;}
            for(int k=1;k<=m;k++)
            {
                if(testimony[i][j]==" "+names[k]+" is guilty."&&guilty!=k) {ans++;twice=1;break;}
                if(testimony[i][j]==" "+names[k]+" is not guilty."&&guilty==k) {ans++;twice=1;break;}
            }
            if(twice==1) break;
        }
    if(ans!=n)
        for(int i=1;i<=m;i++)
        {
            if(num[i]==0) ans++;
            if(ans==n) break;
        }
    return ans;
}
int read()
{
    char c=getchar();
    int ans=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
    {
        ans=ans*10+c-48;
        c=getchar();
    }
    return ans;
}
string gl()
{
    string sss,c;
    do
    {
        cin>>c;
        sss=sss+" "+c;
    }
    while(c[c.size()-1]!='.'&&c[c.size()-1]!='?'&&c[c.size()-1]!='!'&&c[c.size()-1]!=',');
    return sss;
}
int main()
{
    m=read();n=read();p=read();
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        name[s]=i;
        names[i]=s;
    }
    for(int i=1;i<=p;i++)
    {
        cin>>s;
        s=s.substr(0,s.size()-1);
        ss=gl();
        if(crap(ss)) continue;
        num[name[s]]++;
        testimony[name[s]][num[name[s]]]=ss;
    }
    int flag=0;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=7;j++)
            if(check(i,j)==n&&judge(i,j))
            {
                if(flag!=0)
                {
                    cout<<"Cannot Determine"<<endl;
                    return 0;
                }
                else
                {
                    flag=i;
                    break;
                }
            }
    if(flag==0) cout<<"Impossible"<<endl; else cout<<names[flag]<<endl;
    return 0;
}

```","type":"题解","status":2,"postTime":1509965199,"author":{"uid":20158,"name":"Ebola","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Orange","ccfLevel":9,"background":""},"thumbUp":7,"commentCount":8,"currentUserVoteType":0,"contentDescription":"大家不要被体面吓到，其实这题不算很难
总体思路
首先是读入，我采用了一个二维数组来保存证言，第一维是人名，第二维表示此人说的第几句话。接下来我们进行枚举，第一重循环枚举人名（1~m），第二重循环...","id":1692,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"

对应题目：noip2003提高组\_侦探推理


使用语言：c++


使用编译器：dev c++


使用算法：穷举模拟


算法运行时间：O(p\*C(m,n)) + O(m\*C(m,n)) [其中C(m,n)是从m个数中取n个数的组合数]


联系QQ：44561907


E-Mail：44561907@qq.com


获得更多文章请访问我的博客：www.cnblogs.com\/sdjl


如果发现BUG或有写得不好的地方请发邮件告诉我:)



 =========题目解析========

在做此题之前，我们需要搞清楚几点，这是我从测试数据中看出而从题目上不容易看出来的：


题目补充点一：如果有4个人a、b、c、d，当a、b说谎话时我们推出了c是罪犯，然后当a、c说谎话时我们又推出了c是罪犯，此时我们仅推出一个罪犯，而不是两个，因此输出为c，而不是输出Cannot Determine，注意不要重复计数。


题目补充点二：如果有4个人a、b、c、d，当我们推出a、b、c三人都不是罪犯而d未知时，那么d就是罪犯，这是从某些测试数据中发现的规则，题目没有明说。


题目补充点三：不会出现重名情况。


题目补充点四：注意“I am guilty.”、“Today is Monday.”等语句的后面均有一个“.”号。


在确定上面几点后我们来思考此题如何做，首先我想到的是用模拟方法，并且此程序使用的就是模拟方法，也就是说，我们用组合的方式从m个人中取出n个人假设这n个人说谎话，然后分别对这m个人所说的共p句话进行判断，如果p句话均两两不矛盾的话，那么就看看能不能正好找出一个罪犯，或者正好找出m-1个“好人”的话（“好人”指不是罪犯的人，下同），另一个便认为是罪犯。


同时注意分析，本质上有效的证言仅有4种类型，第一种是“谁是罪犯”，第二种是“谁不是罪犯”，第三种是“今天是星期几”，第四种是“今天不是星期几”，并且如果某个说谎者的证言类型为“谁是罪犯”，那么他的反证言“谁不是罪犯”一定成立。


无论在这n个人说谎的情况下能不能找出罪犯，都要从m个人中重新找出一组n个人的组合，再次进行判断（即寻找罪犯）。


直到所有说谎人的组合情况都考虑后再来看哪些人有可能是罪犯，如果超过两个，则输出Cannot Determine，如果正好有一个，则输出此人的名字，如果一个都没有，则输出Impossible。


\*\/









```cpp
 #include 
 #include 
 #include 
 using namespace std;
 const int maxn=20;\/\/最多参与人数
 const int maxTestimony=100;\/\/最多证词数
 \/\/证词枚举类型，分别对应“I am guilty.”、“I am not guilty”、“Today is XXX”、“Today not is XXX”及其它废话。
 enum TestimonyWordsType
 {
```
IsGuilty,NotIsGuilty,TodayIs,TodayNotIs,NullWords




```cpp
 };
 \/\/星期枚举类型，分别从“星期一”对应到“星期日”，最后一个是“未知”，注意，枚举事实上是一个从0开始计数的整数，Monday事实上等于0，Tuesday等于1，Unknown等于7，因此后面代码出现诸如“isToday[Monday]=1”的代码时请不要惊讶，这表示今天是星期一
 enum WeekType
 {
```
Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday,Unknown




   
























   





   
           




   
       
   
   










```cpp
 };
 \/\/证言结构体
 struct TestimonyStruct
 {
   TestimonyWordsType Words;\/\/证言的类型，IsGuilty、NotIsGuilty、TodayIs、TodayNotIs、NullWords五个之一
   TestimonyWordsType Reverse;\/\/证言的反类型，IsGuilty、NotIsGuilty互反，TodayIs、TodayNotIs互反，NullWords的反类型还是NullWords
   int PeopleNum;\/\/说话内容里面所涉及到的人的编号，比如说“SDJL is guilty.”那么就是SDJL此人的编号，此字段仅在Words属于IsGuilty、NotIsGuilty之一时有用
   WeekType Week;\/\/说话内容里面所涉及到的星期，比如说“Today is Monday.”那么Week就等于Monday，此字段仅在Words属于TodayIs、TodayNotIs之一时有用
   int SpeakerNum;\/\/说话者编号
 };
 \/\/人结构体
 struct PeopleStruct
 {
   string Name;\/\/人名
   int Num;\/\/编号
 };
 PeopleStruct people[maxn];\/\/人
 int n;\/\/说谎者人数
 int m;\/\/总人数
 int p;\/\/证言数，注意一个人可能有多句证言，或没有证言
 int StoryPeople[maxn];\/\/StoryPeople[3]=5表示第3个说谎者是people[5]（从第0个开始计数），此全局变量仅用于保存组合算法的状态，其它地方不会用到
 bool isStoryPeople[maxn];\/\/isStoryPople[5]=true表示第5个人说的是谎话，此全局变量在组合算法中得到它的值，而在验证机中用来判断某人是否说谎话
 TestimonyStruct testimony[maxTestimony];\/\/证言
 int guilty[maxn];\/\/guilty[3]=2表示两次推出第3个人是罪犯，等于0表示不能推出此人是罪犯，这里我们不能简单的用一个整数来记录找出的罪犯数以及用一个字符串来记录罪犯的名字，这是因为要避免前面所提到的“题目补充点一”情况。
 \/\/这两个全局变量用于验证机 
 int peopleIsGuilty[maxn];\/\/peopleIsGuilty[7]=1表示第7个人是罪犯，=-1表示不是罪犯，=0表示未知 
 int isToday[7];\/\/isToday[3]=1 表示今天是星期四， isToday[6]=-1 表示今天不是星期日，别忘了是从0开始计数，等于0时表示未知,isToday数组中最多只能有一个为1
 \/\/根据人名得到此人的编号
 int GetPeopleNum(string name)\/\/运行时间：O(m) 
 {
   for(int i=0; i>m>>n>>p;
   \/\/读取名字，并初始化people 
   for(int i=0; i>name;
       people[i].Name = name;        
       people[i].Num = i;        
   }
   \/\/申明一个没用的字符串然后使用函数getline(inputFile,temp,'\n')，这是为了让文件读取指针指向下一行的开头
   string temp;
   getline(inputFile,temp,'\n');
   \/\/读取p句证词 
   for(int i=0; i<p; i++)\/\/每次运行时间：O(pm)
   {
       \/\/从文件中读取说话者姓名
       string speakerName;
       getline(inputFile,speakerName,':');
       \/\/由姓名得到说话者编号
       int speakerNum = GetPeopleNum(speakerName);\/\/每次运行时间：O(m)
       \/\/从文件中读取证词
       string testimonyWords;
       getline(inputFile,testimonyWords,'\n');
       \/\/给第i句证词赋值，注意函数执行前testimony[i]的各个字段是未知的
       SetTestimony(speakerNum,testimonyWords,testimony[i]);\/\/每次运行时间：O(m)
   } 
   inputFile.close();
   \/\/我们假设编号从0到n-1的这n个人说谎
   for(int i=0; i<n; i++)\/\/每次运行时间：O(n)
       StoryPeople[i] = i;
   for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
   {
       isStoryPeople[i] = false;    
   }
   for(int i=0; i<n; i++)\/\/每次运行时间：O(n)
   {
          isStoryPeople[StoryPeople[i]] = true;
   }
   \/\/初始化全局变量guilty
   for(int i=0; i<n; i++)\/\/每次运行时间：O(n)
       guilty[i] = 0;
}
\/\/初始化证言验证机器，初始化后验证机认为所有的人都是未知的，并且也不知道今天是星期几
void ResetCheckupMachine()\/\/运行时间：O(m)
{
   for(int i=0; i<m; i++)
       peopleIsGuilty[i] = 0;\/\/别忘了等于0表示未知，等于1表示是罪犯，等于-1表示不是罪犯
   for(int i=0; i<7; i++)
       isToday[i] = 0;\/\/类似peopleIsGuilty
}
\/\/验证一句证言，使用前要调用“初始化证言验证机”函数
bool Checkup(TestimonyStruct &testimony)\/\/运行时间：O(1)
{
   \/\/申明用于检验的证词类型
   TestimonyWordsType testimonyWordsType;
   \/\/获得说话者编号
   int speakerNum = testimony.SpeakerNum;
   \/\/如果他说假话
   if(isStoryPeople[speakerNum])
       testimonyWordsType = testimony.Reverse;\/\/用于检验的证词为反证词
   else\/\/否则说真话 
       testimonyWordsType = testimony.Words;
   bool consistent;\/\/consistent=false表示证言不一致（矛盾） 
   \/\/获得证词中所涉及的星期
   int weekNum = testimony.Week;
   \/\/分别考虑证词的每种情况，注意证言验证机把testimonyWordsType看为正确的，哪怕它是由说谎者说出来的
   switch(testimonyWordsType)
   {
       \/\/如果证词是“I am guilty.”类型
       case IsGuilty:
           \/\/假如证言验证机已经确定此人不是罪犯
           if(peopleIsGuilty[testimony.PeopleNum] == -1)
               consistent = false;\/\/证言矛盾
           else
           {
               \/\/否则证言不矛盾
               consistent = true;
               \/\/记下曾经有人说过这个人是罪犯
               peopleIsGuilty[testimony.PeopleNum] = 1;
           }
           break;
       \/\/如果证词是“I am not guilty.”类型
       case NotIsGuilty:
           \/\/假如证言验证机已经确定此人就是罪犯
           if(peopleIsGuilty[testimony.PeopleNum] == 1)
               consistent = false;\/\/证言矛盾
           else
           {
               \/\/否则证言不矛盾
               consistent = true;
               \/\/记下曾经有人说过这个人不是罪犯
               peopleIsGuilty[testimony.PeopleNum] = -1;    
           }            
           break;
       \/\/如果证言是“Today is XXX”类型，不失一般性，下面我们假设XXX代表星期三
       case TodayIs:
           \/\/如果证言验证机已经确定今天不是星期三
           if(isToday[weekNum] == -1)
               consistent = false;\/\/证言矛盾
           else
           {
               \/\/记下今天是星期三
               isToday[weekNum] = 1;
               \/\/count用于记算一共确定了几次星期，比如说上一次确定是星期二，而这一次又确定是星期三，那么count就会在isToday[Tuesday]==1时增加1，和在isToday[Wednesday]==1时增加1
               int count=0;
               for(int i=0; i<7; i++)
                   if(isToday[i] == 1)
                       count++;
               \/\/如果仅确定了一次
               if(count ==1)
                   consistent = true;\/\/证言不矛盾
               else\/\/否则确定过多次
                   consistent = false;\/\/证言矛盾
               \/**\/\/*
```
Q：为什么不用一个全局变量来记录今天是星期几呢？
A：因为当遇到证言为“Today is not XXX”时证言验证机需要记下今天不是星期几（及设置isToday[XXX]=-1），而这是用一个全局变量做不到的

\*\/
```cpp
           }        
           break;
       \/\/如果证言是：“Today is not XXX”类型，同样，下面我们假设XXX代表星期三
       case TodayNotIs:
           \/\/如果证言验证机已经确定今天就是星期三
           if(isToday[weekNum] == 1)
               consistent = false;\/\/证言矛盾
           else
           {
               \/\/记下今天不是星期三
               isToday[weekNum] = -1;
               \/\/证言不矛盾
               consistent = true;
           }            
           break;
```
default:
\/\/对于其它废话我们认为它与所有证言都不矛盾





   




   
       
       
```cpp
           consistent = true;
           break;        
   }
   \/\/返回此句证言是否矛盾
   return consistent;
}
\/\/计算下一组说谎话的人，当所有组合均依次出现后函数返回false，关于组合算法请参考我的另一篇文章 
bool NextGroupStoryPeople()\/\/运行时间：O(m) [注意m>n]
{
   bool hasNext;
   int k = n - 1;
   while ((k >= 0) && (StoryPeople[k] + (n - k) == m))
   {
       k--;
   }
   if (k>=0)
   {
      if (k==n-1)
      {
          StoryPeople[k]++;
      }
      else
      {
           StoryPeople[k]++;
           k++;
           while (k<n)
           {
               StoryPeople[k] = StoryPeople[k - 1] + 1;
               k++;
           }
      }
      hasNext = true;
      \/\/计算说谎的人，别忘了StoryPeople用来保存组合的状态，便于生成下一个组合，并不用于其它函数，而isStoryPeople在验证证言时会用到
      for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
      {
           isStoryPeople[i] = false;    
      }
      for(int i=0; i<n; i++)
      {
           isStoryPeople[StoryPeople[i]] = true;
      }
   }
   else
   {
       hasNext = false;
   }
   return hasNext;    
}
\/\/运行整个模拟查找过程
void run()\/\/运行时间：O(p*C(m,n))+O(m*C(m,n)) [是否等于O((m+p)*C(m,n))???]
{
   do\/\/运行时间：C(m,n)*(O(p)+O(m))
   {        
       \/\/重置证言验证机，以便开始验证接下来的证言
       ResetCheckupMachine();     \/\/每次运行时间：O(m)
       bool consistent = true;\/\/consistent=false表示证言出现矛盾 
       \/\/依次验证p句证言
       for(int i=0; i<p; i++)\/\/每次运行时间：O(p)
       {
           consistent = Checkup(testimony[i]);\/\/每次运行时间：O(1)
           \/\/如果证言出现矛盾
           if(!consistent)
               break;\/\/跳出验证循环
       } 
       \/\/如果证言不矛盾 
       if(consistent)
       {
           \/\/统计罪犯数
           int guiltyCount=0;
           for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
           {
               \/\/如果第i个人是罪犯，注意peopleIsGuilty在每次重置证言验证机时被初始化
               if(peopleIsGuilty[i] == 1)
               {
                   \/\/罪犯数增加1
                   guiltyCount++;    
               }
           }    
           \/\/如果根据证言能够恰好有一个罪犯（表示在这次由n个人组成说谎者的情况下正好找到了一个罪犯）
           if(guiltyCount == 1)
           {
               \/\/寻找到那个罪犯
               for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
               {
                   if(peopleIsGuilty[i] == 1)
                   {
                       guilty[i]++;\/\/此步不懂的话到申明处看看guilty的注释
                       break;
                   }
               }    
           }    
           else\/\/否则不能恰好找到一个罪犯（根据题目补充点四，我们判断是否恰好有m-1个人不是罪犯）
           {
               \/\/统计不是罪犯的人数
               int notGuiltyCount = 0;
               for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
               {
                   if(peopleIsGuilty[i] == -1)
                   {
                       notGuiltyCount++;    
                   }
               }    
               \/\/如果根据证言能够恰好有m-1个人不是罪犯
               if(notGuiltyCount == m-1)
               {
                   \/\/找出那个不能推出是不是罪犯的人
                   for(int i=0; i<m; i++)\/\/每次运行时间：O(m)
                   {                        
                       if(peopleIsGuilty[i] != -1)
                       {
                           \/\/那么我们认为他是罪犯
                           guilty[i]++;
                           break;
                       }
                   }    
               }            
           }
       }
   }while(NextGroupStoryPeople());\/\/直到所有说谎组合均考虑过后。运行次数C(m,n),NextGroupStoryPeople运行时间为：O(m) 
   \/**\/\/*
```
我们也可以在找到两个罪犯时退出模拟寻找过程以便提高程序效率，因为题目要求当能找到多于1个罪犯时仅输出“Cannot Determine”
\*\/





```cpp
}
\/\/输出结果，此函数说明略
void show()\/\/运行时间：O(m)
{
   int guiltyCount = 0;
   string guiltyName;
   for(int i=0; i0)
       {
           guiltyCount++;
           guiltyName = people[i].Name;
       }
   }
   switch(guiltyCount)
   {
       case 0:
           cout<<"Impossible"<<endl;
           break;    
       case 1:
           cout<<guiltyName<<endl;
           break;
```
default:
   



```cpp
           cout<<"Cannot Determine"<B。然后我们tarjan缩个点,缩完点的图是个森林。

这样我们只需要去枚举无入度的点是真是假就可以了,按照拓扑序进行更新。

然后判断最后真假的人数就可以了。对于可行的方案我们暴力判断就可以了....

(虽然感觉这种方法并没有好写多少....)
","type":"题解","status":2,"postTime":1501311218,"author":{"uid":16749,"name":"shadyqwq","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":8,"background":""},"thumbUp":4,"commentCount":2,"currentUserVoteType":0,"contentDescription":"看起来好像没人说2-sat(伪)....我来提供一个思路。
我们发现每个人是真话还是假话可能有一些依赖关系,例如这样:
A:我有罪
B:A没罪
C:A有罪
D:今天周一
E:今天周二
下面当我说...","id":1688,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"其实这题的思路，楼下已经讲得很清楚了，但是楼下的c++代码不能AC，因为Linux和Windows的换行符不一样的问题导致很多人只有30分。我们不能用整行读入那该怎么办呢？方法很简单但是有的奇葩，由于每个人说的是一个句子，所以结尾一定会有一个结束符号（。或？或者！）然后只要判断是否读到那个符号就行了。

附上代码（思路跟楼下类似）

```cpp
#include
#include
#include
#include
using namespace std;
int n,m,p,s[22][102],l[22],d[22][102],day[22][102],gu[22];
mapt;
maph;
string u,v[102],g[102],q[102],bb;
int main()
{
    scanf("%d%d%d",&m,&n,&p);
    for (int i=0;i>u;t[u]=i+1;h[i+1]=u;}
    for (int i=0;i>bb;if (ll>1)u+=' ';u+=bb;ll=u.length();}
        for (int j=0;j<ll&&u[j]!=':';j++)
        {v[i]+=u[j];y=j;}
        int jj=t[v[i]],b=-1,nn=0,uu=0;
        for (int j=y+3;j<ll;j++)
        {
            if (!uu)g[i]+=u[j];else q[i]+=u[j];
            if (!nn && !uu && u[j+1]==' ')for (int k=1;k<=m;k++)if (h[k]==g[i]){b=k;break;}
            if (b!=-1 && !nn && !uu){g[i]=u[j+2];j+=2;nn=1;}
            if (g[i]=="Today is ")uu=1;
        }
        if (g[i]=="I am guilty.")s[jj][l[jj]++]=1;
        if (g[i]=="I am not guilty.")s[jj][l[jj]++]=2;
        if (g[i]=="is guilty."){s[jj][l[jj]]=3;d[jj][l[jj]++]=b;}
        if (g[i]=="is not guilty."){s[jj][l[jj]]=4;d[jj][l[jj]++]=b;}
        if (g[i]=="Today is ")
        {
            s[jj][l[jj]]=5;
            if (q[i]=="Monday.")day[jj][l[jj]++]=1;
            if (q[i]=="Tuesday.")day[jj][l[jj]++]=2;
            if (q[i]=="Wednesday.")day[jj][l[jj]++]=3;
            if (q[i]=="Thursday.")day[jj][l[jj]++]=4;
            if (q[i]=="Friday.")day[jj][l[jj]++]=5;
            if (q[i]=="Saturday.")day[jj][l[jj]++]=6;
            if (q[i]=="Sunday.")day[jj][l[jj]++]=7;
        }
    }
    for (int i=1;i<=m;i++)
    for (int j=1;j<=7;j++)
    {
        int fa=0,T,F,abc=0;
        for (int k=1;k<=m;k++)
        {
            T=F=0;
            for (int kk=0;kk<l[k];kk++)
            {
                if (s[k][kk]==1)
                {
                    if (i==k)T=1;else F=1;
                }
                if (s[k][kk]==2)
                {
                    if (i!=k)T=1;else F=1;
                }
                if (s[k][kk]==3)
                {
                    if (i==d[k][kk])T=1;else F=1;
                }
                if (s[k][kk]==4)
                {
                    if (i!=d[k][kk])T=1;else F=1;
                }
                if (s[k][kk]==5)
                {
                    if (j==day[k][kk])T=1;else F=1;
                }
            }
            if (T && F)break;
            if (F)fa++;
            if (!T && !F)abc++;
        }
        if (T && F)continue;
        if (fa==n || fa<=n && fa+abc>=n)gu[i]=1;
    }
    int ans=0;
    for (int i=1;i<=m;i++)
    if (gu[i])ans++;
    if (!ans)printf("Impossible");
    else if (ans>1)printf("Cannot Determine");
    else for (int i=1;i<=m;i++)if (gu[i]){cout<m then
    begin
    if ge=n then
      begin
      ff:=true;
      xiong:=[];
      bu:=[];
      time:=0;
      butime:=[];
      for i:=1 to m do
        begin
        if kk[i]=0 then
          begin
          if a[i,1]=1 then
            begin
            if (i in bu) then begin ff:=false; break; end;
            xiong:=xiong+[i];
            end;
          if a[i,2]=1 then
            begin
            if (i in xiong) then begin ff:=false; break; end;
            bu:=bu+[i];
            end;
          for j:=1 to a3[i,0] do
            begin
            if a3[i,j] in bu then begin ff:=false; break; end;
            xiong:=xiong+[a3[i,j]];
            end;
          if ff=false then break;
          for j:=1 to a4[i,0] do
            begin
            if a4[i,j] in xiong then begin ff:=false; break; end;
            bu:=bu+[a4[i,j]];
            end;
          if ff=false then break;
          if a[i,5]<>0 then
            begin
            if a[i,5] in butime then begin ff:=false; break; end;
            if time=0 then time:=a[i,5]
                      else if time<>a[i,5] then begin ff:=false; break; end;
            end;
          end;
        if kk[i]=1 then
          begin
          if a[i,1]=1 then
            begin
            if (i in xiong) then begin ff:=false; break; end;
            bu:=bu+[i];
            end;
          if a[i,2]=1 then
            begin
            if (i in bu) then begin ff:=false; break; end;
            xiong:=xiong+[i];
            end;
          for j:=1 to a3[i,0] do
            begin
            if a3[i,j] in xiong then begin ff:=false; break; end;
            bu:=bu+[a3[i,j]];
            end;
          if ff=false then break;
          for j:=1 to a4[i,0] do
            begin
            if a4[i,j] in bu then begin ff:=false; break; end;
            xiong:=xiong+[a4[i,j]];
            end;
          if ff=false then break;
          if a[i,5]<>0 then
            begin
            butime:=butime+[a[i,5]];
            if time=a[i,5] then begin ff:=false; break; end;
            end;
          end;
        end;
      if ff then
        begin
        if ans=-1 then ans:=0;
        xiongge:=0;
        for i:=1 to m do
          if i in xiong then
            begin
            inc(xiongge);
            dang:=i;
            end;
        if xiongge=1 then
          if ans=0 then ans:=dang
                   else if dang<>ans then
                          begin
                          writeln('Cannot Determine');
                          halt;
                          end;
        if xiongge=0 then
          begin
          for i:=1 to m do
            if not(i in bu) then
              begin
              inc(xiongge);
              dang:=i;
              end;
          if xiongge=1 then
            if ans=0 then ans:=dang
                     else if dang<>ans then
                            begin
                            writeln('Cannot Determine');
                            halt;
                            end;
          end;
        end;
      end;
    exit;
    end;
  if ge<n then
    begin
    inc(ge);
    kk[x]:=1;
    dfs(x+1);
    kk[x]:=0;
    dec(ge);
    end;
  dfs(x+1);
end;
begin
  readln(m,n,p);
  for i:=1 to m do
    readln(nam[i]);
  day[1]:='Monday';
  day[2]:='Tuesday';
  day[3]:='Wednesday';
  day[4]:='Thursday';
  day[5]:='Friday';
  day[6]:='Saturday';
  day[7]:='Sunday';{直接把日期存进数组里再挨个比较比较方便。。}
  for i:=1 to p do
    begin
    readln(s);
    pp:=pos(': ',s);
    for j:=1 to m do
      if copy(s,1,pp-1)=nam[j] then
        begin
        delete(s,1,pp+1);
        pp:=pos('I am guilty.',s);{整句话寻找不容易找错，毕竟I'm a pig的话也有的}
        delete(s,pp,12);
        if pp<>0 then a[j,1]:=1;
        pp:=pos('I am not guilty.',s);
        delete(s,pp,16);
        if pp<>0 then a[j,2]:=1;
        pp:=pos(' is guilty.',s);
        while pp<>0 do
          begin
          inc(a3[j,0]);
          k:=pp;
          while (k>1) and (s[k-1]<>' ') do dec(k);
          for e:=1 to m do
            if copy(s,k,pp-k)=nam[e] then
              begin
              a3[j,a3[j,0]]:=e;
              break;
              end;
          delete(s,k,pp-k+11);
          pp:=pos(' is guilty.',s);
          end;
        pp:=pos(' is not guilty.',s);
        while pp<>0 do
          begin
          inc(a4[j,0]);
          k:=pp;
          while (k>1) and (s[k-1]<>' ') do dec(k);
          for e:=1 to m do
            if copy(s,k,pp-k)=nam[e] then
              begin
              a4[j,a4[j,0]]:=e;
              break;
              end;
          delete(s,k,pp-k+15);
          pp:=pos(' is not guilty.',s);
          end;
        pp:=pos('Today is ',s);
        if pp<>0 then
          begin
          k:=pp+8;
          while (k<length(s)) and (s[k+1]<>'.') do inc(k);
          for e:=1 to 7 do
            if copy(s,pp+9,k-pp-9+1)=day[e] then
              begin
              a[j,5]:=e;
              break;
              end;
          delete(s,pp,k-pp+2);
          end;
        break;
        end;
    end;
  ge:=0;
  ans:=-1;
  dfs(1);
  if ans>0 then writeln(nam[ans])
             else if ans=-1 then writeln('Impossible')
                            else writeln('Cannot Determine');
end.
```
其实只要处理好每个人说了哪些话，再枚举哪些人是说真话，判断是否符合，就可以了。

[color=red]注意判断Impossible和Cannot Determine的情况，如果能产生不发生冲突的情况，但得不出凶手，那就判断为Cannot Determine。[\/color]
","type":"题解","status":2,"postTime":1387266048,"author":{"uid":1790,"name":"Belongbb","slogan":null,"badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":2,"commentCount":0,"currentUserVoteType":0,"contentDescription":"这道题我认为只是考了枚举和字符串处理。。。
弱弱认为写Pascal比较有优势。。。

其实只要处理好每个人说了哪些话，再枚举哪些人是说真话，判断是否符合，就可以了。
[color=red]注意判...","id":1682,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"},{"content":"我们枚举犯人和星期，一个一个进行判断。如果成功则记录答案，如果成功且以前已经记录了答案，则说明有多个凶手，输出“Cannot Determine”，如果最后没有答案，则输出“Impossible”。主要是字符串的处理。其他细节见代码注释。

然而我的代码用了getline，在Linux下最后会读入Windows的换行符！！这个问题我找了半天！！后来我把代码稍微改了一下（代码第85~87行的处理），使其兼容Linux和Windows（洛谷和codevs是Linux的，Vijos是Windows的）。
```
include
#include
#include
#include
#include
using namespace std;
const string days[]={
    "Today is Monday.",
    "Today is Tuesday.",
    "Today is Wednesday.",
    "Today is Thursday.",
    "Today is Friday.",
    "Today is Saturday.",
    "Today is Sunday."
};
mapnum;\/\/记录编号
string name[22];\/\/名字
int n,m,p,cnt,ans,TF[102],T,F;\/\/T表示当前说真话的人数，F表示当前说假话的人数，TF[i]表示i说真话还是假话
struct word{\/\/id是说这句话的人的编号，st是说的话
    int id;
    string st;
}f[102];
string s;
bool pdTF(int id,bool b){\/\/判断是否有冲突，返回1表示有冲突
    if(TF[id]==-1){
        TF[id]=b;
        if(b)++T;else ++F;
    }else{
        if(TF[id]==b)return 0;else return 1;
    }
    if(F>m||T>n-m)return 1;
    return 0;
}
void Judge(int Xs,string day){\/\/测试，若有冲突则直接跳出来
    memset(TF,-1,sizeof(TF));
    T=F=0;
    for(int i=1;i<=p;++i){
        int pos;
        pos=f[i].st.find("I am guilty.");
        if(~pos){
            if(pdTF(f[i].id,f[i].id==Xs))return;
        }
        pos=f[i].st.find("I am not guilty.");
        if(~pos){
            if(pdTF(f[i].id,f[i].id!=Xs))return;
        }
        pos=f[i].st.find(" is guilty.");
        if(~pos){
            string now=f[i].st;
            now.erase(pos,11);
            int id=num[now];
            if(pdTF(f[i].id,id==Xs))return;
        }
        pos=f[i].st.find(" is not guilty.");
        if(~pos){
            string now=f[i].st;
            now.erase(pos,15);
            int id=num[now];
            if(pdTF(f[i].id,id!=Xs))return;
        }
        pos=f[i].st.find("Today is ");
        if(~pos){
            if(pdTF(f[i].id,f[i].st==day))return;
        }
    }
    \/*全部语句检测完毕，没有冲突*\/
    if(ans&&ans!=Xs){\/\/已有答案但不是当前凶手，说明有多个凶手
        cout<<"Cannot Determine"<>n>>m>>p;
    for(int i=1;i<=n;++i){
        cin>>name[i];
        num[name[i]]=i;
    }
    for(int i=1;i<=p;++i){
        cin>>s;
        s.erase(s.length()-1,1);
        f[i].id=num[s];
        getline(cin,f[i].st);
        f[i].st.erase(0,1);
        char ch=f[i].st[f[i].st.length()-1];
        if(ch=='\n'||ch=='\r'||ch==' ')
        f[i].st.erase(f[i].st.length()-1,1);
    }
    ans=0;
    for(int i=1;i<=n;++i)
    for(int j=0;j<7;++j)
    Judge(i,days[j]);
    if(!ans)\/\/没有搜到凶手
    cout<<"Impossible"<<endl;else
    cout<<name[ans]<<endl;
    return 0;
}
```
","type":"题解","status":2,"postTime":1541593238,"author":{"uid":124407,"name":"stevewen","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":1,"commentCount":0,"currentUserVoteType":0,"contentDescription":"我们枚举犯人和星期，一个一个进行判断。如果成功则记录答案，如果成功且以前已经记录了答案，则说明有多个凶手，输出“Cannot Determine”，如果最后没有答案，则输出“Impossible...","id":86896,"identifier":"solution-p1039","title":"题解 P1039 【侦探推理】"}],"perPage":10,"count":18},"problem":{"pid":"P1039","title":"[NOIP2003 提高组] 侦探推理","difficulty":5,"fullScore":200,"type":"P"},"acceptSolution":false},"currentTitle":"题解","currentTheme":{"id":559,"header":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-63,"degree":244,"repeat":0,"position":[50,17],"size":[1,1],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"},"sideNav":{"logoBackgroundColor":[23,208,180,1],"color":[255,64,122,1],"invertColor":false,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\SideNavConfig"},"footer":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-2,"degree":0,"repeat":0,"position":[38,73],"size":[0,0],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"}},"currentTime":1694532616,"currentUser":{"followingCount":0,"followerCount":0,"ranking":null,"eloValue":null,"blogAddress":null,"unreadMessageCount":0,"unreadNoticeCount":0,"uid":570994,"name":"kkRookie","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"","verified":true}}"));window._feConfigVersion=1694162564;window._tagVersion=1694530844;