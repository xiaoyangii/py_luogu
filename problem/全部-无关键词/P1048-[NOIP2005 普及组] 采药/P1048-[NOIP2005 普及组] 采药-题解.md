window._feInjection = JSON.parse(decodeURIComponent("{"code":200,"currentTemplate":"ProblemSolution","currentData":{"solutions":{"result":[{"content":"`upd on 2020\/2\/5`:修了当年不会写的 `latex` 以及更正了部分错误

首先，这题是一道水的不能在水的题了

其次，我还是想说这题真的太水了，就是一模一样的01背包问题，输入输出都没改

就是改了一个题目背景

转化时间为背包容量和草药占的量

先讲一下二维 $dp$：

让我假设现在的背包的容量是 $C=10$；

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

用v[i]表示物品价值，w[i]表示物品重量，要使得放入背包的物品价值最大化，我们知道用贪心是不行的！

所以接下来开始动规：

首先定义状态 $dp[i][j]$ 以 $j$ 为容量为放入前i个物品(按 $i$ 从小到大的顺序)的最大价值，那么 $i=1$ 的时候，放入的是物品 $1$ ，这时候肯定是最优的啦！

那考虑一下 $j$，$j$ 是当前容量，如果 $j<5$，那么是不是就不能放，$dp[1][j](j<5)=0$；那如果 $j>5$，就可以放了，$dp[1][j](j>=5)=20$；

接着 $i=2$ 放两个物品，求的就是 $dp[2][j]$ 了，当 $j<5$ 的时候，是不是同样的 $dp[2][j](j<5)$ 等于$0$；那当 $j<6$ 是不是还是放不下第二个，只能放第一个；

那 $j>6$ 呢？是不是就可以放第二个了呢？是可以，但是明显不是最优的，用脑子想了一下，发现 $dp[2][j](j>6)=20$，这个 $20$ 怎么来的呢，当然是从前一个状态来的（注意这里就可以分为两种情况了）：一种是选择第二个物品放入，另一种还是选择前面的物品；

让我们假设一下 $j=10$ 吧，可能会比较好理解！这时候： $dp[2][10] = max((dp[1][10-w[2]])+v[2],dp[1][10])$

$dp[2][10] = max(dp[1][4])+10,dp[1][10])$

是不是很明显了呢，$dp[1][4]+10$ 是选择了第二个，于是容量相应就减少成 $4$，之前已经得出 $dp[1][4]=0$，就是说选了物品 $2$，物品 $1$ 就选不了了；$dp[1][10]$ 是不选择第二个，只选择第一个 $dp[1][10]$ 是等于 $20$ 的，于是得出 $dp[2][10]=20$

到这里就可以了，依次类推，动态转移方程为：$dp[i][j] = max(dp[i-1][j-w[i]])+v[i],dp[i-1][j])$

但是好像还有一些问题没考虑完.........

看回例子：

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

我们知道 $dp[1][j](j<5)=20$，$dp[2][j](j=5)$ 的时候是多少呢？我们看到动态转移方程并没有考虑 $j<w[i]$ 的情况，但是我们可以加进去，由于 $dp[2][5]$ 我们看出来是等于 $5$ 的，为什么？因为不能选第二个，只能选第一个，所以..... $dp[2][5]$ 是不是刚好等于 $dp[1][5]$ 了呢！所以当 $j<w[i]$ 的时候，$dp[i][j] = dp[i-1][j]$ 就好了，是不是很神奇呢！

二维 $dp$ 代码：

```cpp
#include "iostream"
#include "stdio.h"
using namespace std;
int w[105],val[105];
int dp[105][1005];
int main()
{
    int t,m,res=-1;
    scanf("%d%d",&t,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&val[i]);
    }
    for(int i=1;i<=m;i++) 
        for(int j=t;j>=0;j--)  
        {
            if(j>=w[i])
            {
                dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
            }  
            else
            {
                dp[i][j]=dp[i-1][j];
            }              
        }
    printf("%d",dp[m][t]);
    return 0;
}
```
我们再用一维dp看看，我们减掉选到哪一个物品这一维

有人就要说了，会重复放入

让我假设现在的背包的容量是 $C=10$；

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

---------------------------------------

直接分析dp数组：

`dp：0 0 0 0 0 0 0 0 0 0`

```cpp
i=1:
dp[10] = max(dp[5]+20, dp[10]);
dp[9] = max(dp[4]+20, dp[9]);
dp[8] = max(dp[3]+20, dp[8]);
dp[7] = max(dp[2]+20, dp[7]);
dp[6] = max(dp[1]+20, dp[6]);
dp[5] = max(dp[0]+20, dp[5]);
```
`dp: 0 0 0 0 20 20 20 20 20 20`
---------------------------------------------

```cpp
i=2:
dp[10] = max(dp[6]+4, dp[10]);
dp[9] = max(dp[3]+10, dp[9]);
dp[8] = max(dp[2]+10, dp[8]);
dp[7] = max(dp[1]+10, dp[7]);
dp[6] = max(dp[0]+10, dp[6]);
```
`dp: 0 0 0 0 20 20 20 20 20 20 \/\/看到了没，选10的都被之前的20压下去了`
-------------------------------------------
```cpp
i=3:
dp[10] = max(dp[6]+12, dp[10]);
dp[9] = max(dp[5]+12, dp[9]);
dp[8] = max(dp[4]+12, dp[8]);
dp[7] = max(dp[3]+12, dp[7]);
dp[6] = max(dp[2]+12, dp[6]);
dp[5] = max(dp[1]+12, dp[5]);
dp[4] = max(dp[0]+12, dp[4]);
```
`dp: 0 0 0 12 20 20 20 20 32 32`
-----------------------------------------

$dp[10]$ 就是背包容量为 $10$ 的时候的最大价值，就是要求的值了，可以看到，容量大的时候的值取决于容量小的时候的值，从而不断被正确更新，所以用一维 $dp$ 的时候，$j$ 的循环必须是从大到小逆序开始的，逆序，就防止了一个物品放入多次！！！否则...........

直接分析 $dp$ 数组：

`dp：0 0 0 0 0 0 0 0 0 0`

```cpp
i=1:
dp[5] = max(dp[0]+20, dp[5]);
dp[6] = max(dp[1]+20, dp[6]);
dp[7] = max(dp[2]+20, dp[7]);
dp[8] = max(dp[3]+20, dp[8]);
dp[9] = max(dp[4]+20, dp[9]);
dp[10] = max(dp[5]+20, dp[10]);
dp: 0 0 0 0 20 20 20 20 20 40 \/\/看到问题了吗！dp[10]不仅仅是由dp[5]决定了，因为dp[5]还被dp[0]更新了一次，相当于，i=1时，即只有一个物品时，这个物品拿了两次，完全不符合01背包了，但是，这个却是我们后面要提到的完全背包！接着看：
```
---------------------------------------------
```cpp
i=2:
dp[6] = max(dp[0]+10, dp[6]);
dp[7] = max(dp[1]+10, dp[7]);
dp[8] = max(dp[2]+10, dp[8]);
dp[9] = max(dp[3]+10, dp[9]);
dp[10] = max(dp[4]+10, dp[10]);
```
`dp: 0 0 0 0 20 20 20 20 20 40`
-------------------------------------------

```cpp
i=3:
dp[4] = max(dp[0]+12, dp[4]);
dp[5] = max(dp[1]+12, dp[5]);
dp[6] = max(dp[2]+12, dp[6]);
dp[7] = max(dp[3]+12, dp[7]);
dp[8] = max(dp[4]+12, dp[8]);
dp[9] = max(dp[5]+12, dp[9]);
dp[10] = max(dp[6]+12, dp[10]);
```
`dp: 0 0 0 12 20 20 20 24 32 40`

分析完毕，之后自己想吧

重点就是，一维内层循环要倒着来！不然会重复

一维 $dp$ 代码：

```cpp
#include "stdio.h"
#include "iostream"
using namespace std;
int w[105], val[105];
int dp[1005];
int main()
{
    int t,m,res=-1;    
    scanf("%d%d",&t,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&val[i]);
    }
    for(int i=1;i<=m;i++) 
    {
        for(int j=t;j>=0;j--) 
        {
            if(j>=w[i])
            {
                dp[j]=max(dp[j-w[i]]+val[i], dp[j]);
            }
        }
    }    
    printf("%d",dp[t]);
    return 0;
}
```","type":"题解","status":2,"postTime":1508763705,"author":{"uid":48265,"name":"decoqwq","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Green","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/ag5ib190.png"},"thumbUp":1856,"commentCount":401,"currentUserVoteType":0,"contentDescription":":修了当年不会写的  以及更正了部分错误
首先，这题是一道水的不能在水的题了
其次，我还是想说这题真的太水了，就是一模一样的01背包问题，输入输出都没改
就是改了一个题目背景
转化时间为背包容量...","id":1898,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"# 聊聊动态规划与记忆化搜索

by $\color{Gray}{InterestingLSY}$ (菜到发灰) ，在此一并感谢 [$\color{purple}{ComeIntoPower}$](https:\/\/www.luogu.org\/space\/show?uid=11751)dalao的指点qwq

> 想体验把暴搜改改就是正解的快感吗? 想体验状压dp看似状态多到爆炸实际一跑却嗷嗷快(实际有效的状态数很少)的荣耀吗? 记忆化搜索,符合您的需求!只要998,记忆化搜索带回家!记忆化搜索,记忆化搜索,再说一遍,记忆化搜索!

先点个赞吧(逃

*由于我讲的比较磨叽,兜售目录一份,dalao们可以选择自己喜欢的部分看*

## 目录：

- 记忆化搜索是啥

- 记忆化搜索和动态规划有啥关系

- 如何写记忆化搜索

- 记忆化搜索的优缺点

- 记忆化搜索的注意事项

- 相关文章推荐

---

## 1. 记忆化搜索是啥（引入

好，就以 [这道题](https:\/\/www.luogu.org\/problemnew\/show\/P1048) 为例，我不会动态规划，只会搜索，我就会直接写一个粗暴的 DFS :

*注: 为了方便食用, 本文中所有代码省略头文件*

```cpp
int n,t;
int tcost[103],mget[103];
int ans = 0;
void dfs( int pos , int tleft , int tans ){
    if( tleft < 0 ) return;
    if( pos == n+1 ){
		ans = max(ans,tans);
		return;
	}
	dfs(pos+1,tleft,tans);
    dfs(pos+1,tleft-tcost[pos],tans+mget[pos]);
}
int main(){
    cin >> t >> n;
    for(int i = 1;i <= n;i++)
        cin >> tcost[i] >> mget[i];
    dfs(1,t,0);
	cout << ans << endl;
    return 0;
}
```
这就是个十分智障的大暴搜是吧......

emmmmmm....... $\color{Red}{30}$ 分

然后我心血来潮, 想不借助任何 "外部变量"(就是 dfs 函数外且 ** 值随 dfs 运行而改变的变量 **), 比如 ans

把 ans 删了之后就有一个问题: 我们拿什么来记录答案?

答案很简单:

** 返回值!**

此时 $dfs(pos,tleft)$ 返回在时间 $tleft$ 内采集 ** 后 **$pos$ 个草药, 能获得的最大收益

不理解就看看代码吧:

```cpp
int n,time;
int tcost[103],mget[103];
int dfs(int pos,int tleft){
    if(pos == n+1)
        return 0;
    int dfs1,dfs2 = -INF;
    dfs1 = dfs(pos+1,tleft);
	if( tleft >= tcost[pos] )
    	dfs2 = dfs(pos+1,tleft-tcost[pos]) + mget[pos];
    return max(dfs1,dfs2);
}
int main(){
    cin >> time >> n;
    for(int i = 1;i <= n;i++)
        cin >> tcost[i] >> mget[i];
    cout << dfs(1,time) << endl;
    return 0;
}
```

~~emmmmmm....... 还是 $\color{Red}{30}$ 分~~

但这个时候, 我们的程序已经不依赖任何外部变量了.

然后我非常无聊, 将所有 dfs 的返回值都记录下来, 竟然发现......

** 震惊, 对于相同的 pos 和 tleft,dfs 的返回值总是相同的!**

想一想也不奇怪, 因为我们的 dfs 没有依赖任何外部变量.

旁白: 像 $tcost[103]$,$mget[103]$ 这种东西不算是外部变量, 因为她们在 dfs 过程中不变.

然后?

开个数组 $mem$ , 记录下来每个 $dfs(pos,tleft)$ 的返回值. 刚开始把 $mem$ 中每个值都设成 $-1$ (代表没访问过). 每次刚刚进入一个 dfs 前(我们的 dfs 是递归调用的嘛), 都检测 $mem[pos][tleft]$ 是否为 $-1$ , 如果是就正常执行并把答案记录到 $mem$ 中, 否则?

** 直接返回 $mem$ 中的值!**

```cpp
int n,t;
int tcost[103],mget[103];
int mem[103][1003];
int dfs(int pos,int tleft){
	if( mem[pos][tleft] != -1 ) return mem[pos][tleft];
    if(pos == n+1)
        return mem[pos][tleft] = 0;
    int dfs1,dfs2 = -INF;
    dfs1 = dfs(pos+1,tleft);
	if( tleft >= tcost[pos] )
    	dfs2 = dfs(pos+1,tleft-tcost[pos]) + mget[pos];
    return mem[pos][tleft] = max(dfs1,dfs2);
}
int main(){
	memset(mem,-1,sizeof(mem));
    cin >> t >> n;
    for(int i = 1;i <= n;i++)
        cin >> tcost[i] >> mget[i];
    cout << dfs(1,t) << endl;
    return 0;
}
```
此时 $mem$ 的意义与 dfs 相同:

> 在时间 $tleft$ 内采集 **后** $pos$ 个草药, 能获得的最大收益

这能 ac?

能.** 这就是 "采药" 那题的 AC 代码 **

好我们 yy 出了记忆化搜索

#### 总结一下记忆化搜索是啥:

- 不依赖任何 ** 外部变量 **

- 答案以返回值的形式存在, 而不能以参数的形式存在(就是不能将 dfs 定义成 $dfs(pos ,tleft , nowans )$, 这里面的 nowans 不符合要求).

- 对于相同一组参数, dfs 返回值总是相同的

---

## 2. 记忆化搜索与动态规划的关系:（分析

~~基本是朋 (ji) 友关系~~

有人会问: 记忆化搜索难道不是搜索?

一定程度上来说，她是搜索.但个人认为她更像dp

**其实说白了，记忆化搜索就是dp**

不信你看$mem$ 的意义:

> 在时间 $tleft$ 内采集 **后** $pos$ 个草药, 能获得的最大收益

这不就是dp的状态?

由上面的代码中可以看出:

> $dfs(pos,left) = max(dfs(pos+1,tleft-tcost[pos])+mget[pos]\ ,\ dfs(pos+1,tleft)$

即为

> $mem[pos][tleft] = max(mem[pos+1][tleft-tcost[pos]]+mget[pos]\ ,\ mem[pos+1][tleft])$

这不就是dp的状态转移?

总结一下：

> 记忆化搜索和动态规划**从根本上来讲就是一个东西**,**(印象中)任何一个 dp 方程都能转为记忆化搜索 ，反之亦然（为什么？见下文“体现在”的第四条）

体现在

- 根据**记忆化搜索**的参数可以直接得到dp的状态，反之亦然

- 根据**记忆化搜索**的递归关系可以写出状态转移方程，这个方程可以直接写出循环式的dp，只不过是反的(想想为什么？)，反之亦然

- 大部分记忆化搜索时空复杂度与 ** 不加优化的 ** dp 完全相同

- ### 最重要的一点：二者思想类似！！ 核心思想均为：**利用对于相同参数答案相同的特性**，对于相同的参数（循环式的dp体现为数组下标），记录其答案，免去重复计算，从而起到优化时间复杂度的作用。这，便是二者的精髓。**

建议好好想想第四条。记住，学一个算法，一定要理解他的精髓。

举个栗子:

$dp[i][j][k] = dp[i+1][j+1][k-a[j]] + dp[i+1][j][k]$

转为

```cpp
int dfs( int i , int j , int k ){
	边界条件
    if( mem[i][j][k] != -1 ) return mem[i][j][k];
    return mem[i][j][k] = dfs(i+1,j+1,k-a[j]) + dfs(i+1,j,k);
}
int main(){
	memset(mem,-1,sizeof(mem));
	读入
    cout << dfs(1,0,0) << endl;
}
```

二者满足上面提到的所有关系

---

## 3. 如何写记忆化搜索

### 方法I（由动态规划开始思考）:

1. 把这道题的dp状态和方程写出来
2. 根据他们写出dfs函数
3. 添加记忆化数组

举例:

$dp[i] = max\{dp[j]+1\}\quad 1 \leq j < i \text{且}a[j]<a[i]$  (最长上升子序列)

转为

```cpp
int dfs( int i ){
	if( mem[i] != -1 ) return mem[i];
	int ret = 1;
	for( int j = 1 ; j < i ; j++ )
    	if( a[j] < a[i] )
    		ret = max(ret,dfs(j)+1);
    return mem[i] = ret;
}
int main(){
	memset(mem,-1,sizeof(mem));
	读入
    cout << dfs(n) << endl;
}
```
### 方法II（由暴搜开始思考）:

1. 写出这道题的暴搜程序(最好是dfs)
2. 将这个dfs改成"无需外部变量"的dfs
3. 添加记忆化数组

举例: 本文最开始介绍"什么是记忆化搜索"时举的"采药"那题的例子，就是典型的方法II

---

## 4. 记忆化搜索的优缺点

优点:

- 记忆化搜索可以避免搜到无用状态, 特别是在有状态压缩时

 举例: 给你一个有向图(注意不是完全图),经过每条边都有花费,求从点1出发,经过每个点**恰好一次**后的最小花费(最后不用回到起点),保证路径存在.

dp状态很显然:

设 $dp[pos][mask]$ 表示身处在 $pos$ 处,走过 $mask$(mask为一个二进制数) 中的顶点后的最小花费

常规 $dp$ 的状态为 $O(n\cdot 2^n)$ , 转移复杂度(所有的加在一起)为 $O(m)$

但是!如果我们用记忆化搜索,就可以避免到很多无用的状态,比如 $pos$ 为起点却已经经过了 $>1$ 个点的情况.

然后就 $rk1$ 了

- 不需要注意转移顺序(这里的"转移顺序"指正常dp中for循环的嵌套顺序以及循环变量是递增还是递减)

举例: 用常规 dp 写"合并石子"需要先枚举区间长度然后枚举起点,但记忆化搜索直接枚举断点(就是枚举当前区间由哪两个区间合并而成)然后递归下去就行

- 边界情况非常好处理, 且能有效防止数组访问越界

- ~~写起来简单易懂~~ 至少我镇么认为 qwq

- 有些 dp(如区间 dp)用记忆化搜索写很简单但正常 dp 很难

- 记忆化搜索天生携带搜索天赋,可以使用技能"剪枝"!

缺点:

- 致命伤: 不能滚动数组!(哪位 dalao 会记搜 + 滚动的请在评论区留名)

- 有些优化比较难加

- 由于递归, 有时效率较低但不至于 TLE (状压dp除外)

- 代码有点长~~其实也不算太长~~

---

## 5. 记忆化搜索的注意事项

- 千万别忘了加记忆化! (别笑, 认真的

- 边界条件要加在检查当前数组值是否为 - 1 前(防止越界)

- 数组不要开小了(逃

- 在某些时候需要优化（如滚动数组、斜率优化时还是要用正常的dp
---

## 6. 相关文章推荐

《挑战程序设计竞赛》(又名白书)，对动态规划的引入的那一章（它也是从暴搜开始讲起）

## 如有疑问或质疑, 请留下评论或私信我

** questions are welcome **
","type":"算法","status":2,"postTime":1534993069,"author":{"uid":25630,"name":"interestingLSY","slogan":"4e6db374ed2fb0e68073d5d05c3b136e(md5)","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":9,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/86npe8c5.png"},"thumbUp":1193,"commentCount":285,"currentUserVoteType":0,"contentDescription":"聊聊动态规划与记忆化搜索
by $\color{Gray}{InterestingLSY}$ (菜到发灰) ，在此一并感谢 $\color{purple}{ComeIntoPower}$dala...","id":61709,"identifier":"memdfs-and-dp","title":"聊聊动态规划与记忆化搜索"},{"content":"*\/\/我其实早就想写一篇动态规划的文章了，虽然我也很弱……我的思路会和市面上的一些辅导书不同，我直接从背包问题入手，主要面对初学者，讲的比较啰嗦，还会涉及很多优化供学有余力者学习。一旦弄懂了这类比较典型也比较难的问题，动态规划的能力会显著提升。
文章里可能会有纰漏，希望大家帮我指出，~~但是请不要嘴臭~~*



# 动态规划定义

~~没用，想看自行百度（滑稽~~ 

----------

# 一些基本知识和dp（动态规划）的基本认识 

## - 最优化原理和无后效性原则 ##

作为一个弱省蒟蒻，我的粗鄙的理解就是“现在要干的事对之前没有影响而且是最好的”，这也是符合我们的认知规律的。比如说，我们小学时有接触过一类题（当时虐的年幼的我死去活来）
>小明的妈妈要看电视剧，所以小明必须艰苦创业自力更生（雾）。小明早上要干许多事，比如烧水，开电脑luogu签到，上厕所。烧水需要5分钟，上厕所需要2小时（真实），开电脑需要1小时，怎样安排用时最短？

 首先，在生活中，现在做的事肯定不会影响过去（~~起码暂时不会~~ ） ，同样未来做的事也不会影响到现在，这就叫做**无后效性原则**。
 
 那么什么是最优化呢？比如说我们已经开始烧水，那我们现在应该干什么呢，很显然是开电脑，这样我们上完厕所后水也烧好了，电脑也开了（~~痔疮也有了~~ ）。这就是**最优化原理**，我们只要最好的。

## - 记忆化搜索 ##

表面高大上，但是很多人在做水题的时候早就基本掌握这个思想了。

> N！即1 * 2 * 3 ... * N,现在，我们求99！，100！，101！怎么办呢？

~~**显然**~~（粗鄙之言），我们只需要算出99！，就不需要再从头计算了，因为100！即是99！ * 100。

> 如果我要求的是1！，2！...N！呢，并且要求在全部计算完之后输出答案？

显然（逃），我们需要开一个a[101]数组，去保存答案最后输出。这样的话，问题就简单了，我们求N！，只需要知道(N - 1)！，求（N - 1）！，只需要知道（N - 2）！ ……以此类推，我们只需要知道1！ = 1，我们便可以推出2！，进而推出3！……而不需要每次都从头计算。我们将算出的1！，2！……存入a数组，不仅要作为答案输出，还要继续使用它，就好像我们将1！……记下了一样，因此叫记忆化。

### 记忆化搜索中的dp思想 ###

首先，求N！的过程是满足最优化和无后效性的，所以才能想到这道题可以用dp（虽然好像并没有明确的选择最优，但是我们由(N - 1）！得出N！时只有一个选择—— *N，我们别无选择♂时的唯一一个选择，就可以认为是最优的。

作为让OI选手头疼的拦路虎，状态设计和转移方程无数次令我自闭。其实，只要做题时勤于思考，这种思维方式是可以逐步形成的。

上述问题我们仅用了一层循环便解决了问题（仅仅举例，高精度等问题自己把控），既然说是dp，我们该怎样设计状态和书写转移方程呢？

在dp中，有种思想特别有用，这种思想叫做逆推（并不适用于所有题），这道题我们不妨逆推。

上文中，我们已设计好了状态（即由1！求2！进而求3！……），大概是下面这个样子的


![](https:\/\/img-blog.csdnimg.cn\/201905011009415.png?x-oss-process=image\/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTE0Njc3,size_16,color_FFFFFF,t_70)
进而状态转移方程也得到了：a[N] = a[N - 1] * N;

# 0-1背包

我以前是真的觉得dp超级难啊，自从钻研了半个多月之后，~~嗨，效果还真好！我们全家都用它！~~

## 题目

> 她，是无数男人追求不到的纯情少女。
> 他，是曾经的雇佣兵王。
> 或许是冥冥中的缘分使两人相识，他爱上了她。为了保护她，他无意中得罪世界最大恐怖势力僞窿辣条集团（~~雾~~。
> 现在，他只有最后一点钱，再也不能说那句熟悉的”买！都给我买“了，为了保护心爱之人，他必须用有限的钱买尽可能多的辣条，僞窿辣条集团故意难为他，将每包辣条都标上了不同的价格，每包有不同的根数，他很伤心，请你帮帮他。

有M元，共有N种辣条，第N种有v[n]根辣条，价格为w[n]，求最大可买到的辣条数。

## 贪心算法气得爆哭
我们可以轻松构造一批数据来证明贪心算法不可行。

> 只有四种辣条，第一种七元，有九根，第二种六元，有五根，第三种七元，有八根，第四种六元，有六根，我们的雇佣兵王只有19元（~~好惨一男的~~

很明显，第一种和第三种明显比第二种和第四种划算，所以我们如果贪心的话，一定是先选一三，但是选一二四才是真正的答案。为什么呢？因为贪心目光短浅，他选的只是当前的最划算的辣条，而不是全部种类的辣条都考虑，这就导致了会有空间被浪费。用上一章的话来说，贪心算法做的话不满足最优化原理。

**提示** . 通常情况贪心和dp题是很容易看出来的，但是究竟是用贪心还是用动归需要自己证明，这是个很重要的步骤，上文我构造的数据其实是对贪心不可行的证明，我在上一章给出了dp可行的证明，希望大家可以举一反三，证明一下此题符合最优化原理和无后效性原则，进而证明此题可以dp。

## dp解背包问题

背包问题的状态设计和转移方程对于初学者来说是有难度的，我在这里~~假装~~ 推理一下。

首先，因为是01背包，每种辣条只有一包，对于某种辣条，我们仅有两种选择——买或不买，最优选择一定在这两者中。

其次，我们要知道第N种辣条取或不取哪种情况更优，我们就必须先知道第N - 1种辣条取与不取哪种更优，为什么呢？因为我们先取的是第N - 1种，如果我们第N - 1种取的是最优解，那么我们取第N种时的得到的最优解一定比第N - 1不是最优解时得到的要好，我们可以像下图这样理解![在这里插入图片描述](https:\/\/img-blog.csdnimg.cn\/20190501160751526.png?x-oss-process=image\/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTE0Njc3,size_16,color_FFFFFF,t_70)
如果我们简单的通过好\/坏的多少来判断好坏，请问黑色和**绿色**（~~滑稽~~）哪个更好呢？当然是黑色，同理，我们从1选到N，一定是每一包都选最优解咯。

那么，每种辣条的两种选择（取\/不取），我们可以把它们转化成：取，则相当于求用M - w[i] （0 <= i <= N）元买前N - 1种辣条的最优解；不取， 则相当于我们用M元买前N - 1种辣条。为什么取的时候要用M - w[i] 元取呢？因为我们用M - w[i] 元取，就相当于已经把第N种辣条的钱留出来了。类似于我们去饭店恰饭，如果我们提前订好桌，就不必担心没有座位了。

这个推论告诉我们，我们求N的最优解必须知道用m元买N - 1种辣条与用m -w[N] 元买N - 1种辣条哪个更优。但是编号再靠前的辣条我们怎么考虑呢？我们不知道后面有几包辣条取几包不取，所以我们就无法确定到底要留多少钱，既然这样，我们不如把每种辣条从1 — w元都考虑一遍，反正雇佣兵王有的是钱（~~兵王:“胡说！！！”~~）。
（我相信在这里一些同学已经看出了些许猫腻，其实有些物品我们并不需要算出1 — w的最优解，因为排在它编号之后的辣条价格总和可能根本达不到w元，这是本章末会讲到的一个常数优化）

我们可以发现，我们不仅需要考虑每种辣条，还需要考虑每种辣条在1 — w时的解，这么说来，我们需要一个二维数组dp[ i ][ j ]（i为第i种辣条，j为有j元）来保存我们的“记忆”（不错，就是记忆化搜索的记忆）。我们再用w[ i ]储存第i种辣条的价格，用v[ i ]储存第i种辣条的根数，这样，我们就可以用上文推出的东西来写出转移方程了

```
dp[i][j] = max(dp[i - 1][m], dp[i - 1][m - w[i]] + v[i]);
```
为了便于理解，接下来我会给出一个dp的模拟过程。但是在这之前我希望同学们可以自己先推一遍，这是有极大的好处的，我不建议初学者直接跳过。
|钱数\/根数  | 1 | 2 | 3 |  4|  5|  6| 7 | 8 |  9|  10|  11| 12 | 13|  14|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  3\/1|  0| 0 |  1| 1 |1 |  1|  1| 1 | 1 |1  |1  | 1 |1  | 1 |
|  8\/10|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
|  1\/1|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
|  4\/40|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| 7\/25 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |




该图即为dp数组，横行为价格与辣条根数(i)，比如3\/1表示第一种辣条每包三元，每包一根。竖列为钱数(j)。

dp[ 2 ][ 1 ~ N]:
|钱数\/根数  | 1 | 2 | 3 |  4|  5|  6| 7 | 8 |  9|  10|  11| 12 | 13|  14|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  3\/1|  0| 0 |  1| 1 |1 |  1|  1| 1 | 1 |1  |1  | 1 |1  | 1 |
|  8\/10|0  | 0 |  1| 1 |1 |  1|1  |10  |10  |10  | 11 | 11 |11  | 11 |
|  1\/1|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
|  4\/40|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| 7\/25 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |


dp[ 3 ][ 1 ~ N]:
|  |1  | 2 | 3 |  4|5  |6  |7  |8  |9  |10 |11  |12  |13  |14  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 3\/1 | 0 |0  |1  | 1 |1 | 1 | 1 | 1 | 1| 1 |1  |1  | 1 |1  |
|  8\/10|0  | 0 |  1| 1 |1  |  1|1  |10  |10  |10  | 11 | 11 |11  | 11 |
|  1\/1|1  | 1 | 1 | 2 | 2 |  2| 2 |10  |11  |11  |11  |12  |12  |12  |
|  4\/40|  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| 7\/ 25|  |  |  |  |  |  |  |  |  |  |  |  |  |  |

dp[ 4 ][ 1 ~ N]:
|  |1  | 2 | 3 |  4|5  |6  |7  |8  |9  |10 |11  |12  |13  |14  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 3\/1 | 0 |0  |1  | 1 |1 | 1 | 1 | 1 | 1| 1 |1  |1  | 1 |1  |
|  8\/10|0  | 0 |  1| 1 |1  |  1|1  |10  |10  |10  | 11 | 11 |11  | 11 |
|  1\/1|1  | 1 | 1 |2 | 2 |  2| 2 |10  |11  |11  |11  |12  |12  |12  |
|  4\/40| 1 |  1| 1 | 40 |41  |41  |  41| 42 | 42 | 42 |42  |  50|51  |51  |
| 7\/ 25|  |  |  |  |  |  |  |  |  |  |  |  |  |  |

dp[ 5][ 1 ~ N]:
|  |1  | 2 | 3 |  4|5  |6  |7  |8  |9  |10 |11  |12  |13  |14  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 3\/1 | 0 |0  |1  | 1 |1 | 1 | 1 | 1 | 1| 1 |1  |1  | 1 |1  |
|  8\/10|0  | 0 |  1| 1 |1  |  1|1  |10  |10  |10  | 11 | 11 |11  | 11 |
|  1\/1|1  | 1 | 1 | 2 | 2 |  2| 2 |10  |11  |11  |11  |12  |12  |12  |
|  4\/40| 1 |  1| 1 | 40 |41  |41  |  41| 42 | 42 | 42 |42  |  50|51  |51  |
| 7\/ 25|  1| 1 |1  |40  |41  |41  |41  |42  |42  |42  |65  |66  |66  |66  |
(已修正，~~鬼知道我打的破表为什么第一次不能显示~~)

这样，我们便得到了最优解dp[N][M] = 66。

我们一定要把数组开成dp[ 1 ~ N][ 1 ~ M]的，把0都留下，不然可能会数组越界。

练习题
[采药](https:\/\/www.luogu.org\/problemnew\/show\/P1048)
文章最末附上我的AC代码

# 一些小优化
 
 

# 1.滚动数组

这是一个空间优化，可以将二维数组降至一维，在许多位数较高的背包问题中有奇效，建议学习一下。

## 原理
这个优化其实可以通过对转移方程的观察得出。

```cpp

dp[i][j] = max(dp[i - 1][m], dp[i - 1][m - w[i]] + v[i]);

```

我们发现在求dp[i][j]时用到的状态全部来自dp[i - 1][j]，emmmmmm，根据最优化原理和无后效性原则，我们可以知道此时的dp[i - 1][j]已经是最优的而且已经没有用了，所以我们可以直接把dp[i][j]上的内容覆盖到dp[i - 1][j]上去。这样的话，我们只需要一个一维数组就可以解决这个问题了，这是一个对空间的极大优化，空间复杂度由原先的O（N * M）降至了现在的O(M)，但是，请大家观察下面两个代码，看看有什么不同。

70 3

71 100

69 1

1 2

这是输入数据

代码一：


```cpp
	cin >> t >> m;
	
	for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
	
	for(int i = 1; i <= m; i++){
		
		for(int j = t; j >= 1; j--) 
			dp[j] = max(dp[j - w[i]] + v[i], dp[j]);
	}
	
	cout << dp[t];

```

输出  3

代码二：

```cpp


int main（）{
	
	cin >> t >> m;
	
	for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
	
	for(int i = 1; i <= m; i++){
		
		for(int j = 1; j >= t; j++) 
			dp[j] = max(dp[j - w[i]] + v[i], dp[j]);
	}

```

输出0

为什么呢？
不知大家发现没有，这两个代码的第二层循环的顺序改变了，也就是对钱数的循环顺序变了，为什么一个小小的操作会有这么大的影响呢？因为我们在更新dp[i]数组时，用的是dp[i ]和dp[i - w[i]]这两个状态，假如我们从1更新到M，那么当我们更新dp[i]时，dp[i - w[i]]已经被更新过了，它已经不是原来的那个dp[i - w[i]]了，很有可能dp[i - w[i]]已经买了一包第i种辣条，然后我们更新dp[i]时调用dp[i - w[i]]，又买了一包一样的辣条，这不符合01背包。（虽然不符合01背包，但是大家一定也看出来了，这符合一个物品可取多次的情况，即下一章我会讲到的完全背包问题）

接下来，我为大家模拟一遍这个程序

假设一种辣条的费用3，根数为1，第二种费用为8，根数为10。初始dp数组被初始化为0。

```cpp

dp[15] = dp[12] + 1;
dp[14] = dp[11] + 1;
dp[13] = dp[10] + 1;
......
\/\/这一轮更新过后，dp[3~15] = 1， 其余为0；
\/\/第二轮更新：
dp[15] = dp[7] + 10;
dp[14] = dp[6] + 10;
dp[13] = dp[5] + 10;
......
此时dp[1~2] = 0, dp[3~7] = 1, dp[8~10] = 1, dp[11 ~ 15] = 11。

```

可以发现，这和上文中二维数组的模拟结果是一样的。
但是这种方法有一个弊端，就是输出到底买了哪几种辣条时不便。

# 2.常数优化

 

## 1. 优化一
我们在循环的时候，我们可以发现钱数少于w[i]的情况是不会被更新的，因为此时压根买不起第i种辣条，如图
![](https:\/\/img-blog.csdnimg.cn\/20190502100143316.PNG?x-oss-process=image\/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTE0Njc3,size_16,color_FFFFFF,t_70)
我们发现，划横线的那些是完全继承了上次循环的状态。
所以，我们再循环时可以改成从w[i] ~ M。
```cpp


for(int i = 1; i <= m; i++){	
		for(int j = t; j >= w[i]; j--) 
			dp[i] = max(dp[j - w[i]] + v[i], dp[j]);
	}

```

## 2.优化二
这个优化比上一个优化更明显，但是稍微难理解。

由于只需要最后dp[m]的值，倒推前一种辣条，我们只要知道dp[m-w[n]]即可。以此类推，对以第j种辣条，其实只需要知道到dp[m-sum{w[j~n]}]即可。这在钱数较大的时候是比较有用的。代码希望大家自己理解透彻后实现，是比较简单的。



## 01背包讲完了！，你是否有了一些更深层次的理解呢？或许你有一些和我不同的看法，欢迎联系我。01背包非常非常非常重要！一定要完全理解鸭，我们后面会讲到的几种背包问题，都可以变形为01背包，多花一些时间在01背包上真是受益匪浅啊。


AC代码（优化后）

```cpp
using namespace std;

#include 

int t, m, dp[1010], w[110], v[110];

int main(){
	
	ios::sync_with_stdio(false);
	cin >> t >> m;
	
	for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
	
	for(int i = 1; i <= m; i++){
		
		for(int j = t; j >= w[i]; j--) 
			dp[j] = max(dp[j - w[i]] + v[i], dp[j]);
	}
	
	cout << dp[t];
	return 0;
}
```

","type":"题解","status":2,"postTime":1558575585,"author":{"uid":149105,"name":"Indigo_Boy","slogan":"这个家伙很菜，退役了。","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":3,"background":""},"thumbUp":437,"commentCount":85,"currentUserVoteType":0,"contentDescription":"\/\/我其实早就想写一篇动态规划的文章了，虽然我也很弱……我的思路会和市面上的一些辅导书不同，我直接从背包问题入手，主要面对初学者，讲的比较啰嗦，还会涉及很多优化供学有余力者学习。一旦弄懂了这类比...","id":133891,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"# 动态规划->背包->01背包
## 01背包的特点:物品只有一件。~~想放就放，不想放就别放~~
## 思路(1 \/ 2):
>## 1.定义二维数组 , f[i][j]表示采第i株药,花费时间j可以采到的草药的最大总价值。
>## 2.输入采摘某株草药的时间和这株草药的价值。
>## 3.判断是否采摘这株草药
>>### 1.不采摘(背包容量不够),则时间不变,当前采摘的药等于采摘的第i-1株药
```cpp
f[i][j] = f[i - 1][j] ;
```
>>### 2.采摘(背包容量足够),那么当前可以获得的草药为采i-1株草药,时间为少采第i种药的时间j-ti[i]并且加上当前草药的价值pri[i]。
```cpp
f[i][j] = f[i - 1][j - ti[i]] + pri[i] ;
```

>## 这里需要注意 : 如果当前采摘这株草药获得的价值比采摘i-1株草药的价值低的话也不摘。

>## 所以需要比较。因此无论摘不摘这一株草药,一开始的价值都应该是采摘i-1株草药的价值
```cpp
f[i][j] = max(f[i][j], f[i - 1][j - ti[i]] + pri[i]) ;
```
>## 相当于初始化当前可以获得的价值为采摘i-1株草药的价值，只有背包容量足够采摘当前这一株草药的时候,才判断是否采摘当前的这一株草药。
```cpp
	f[i][j] = f[i - 1][j] ;
	if(j >= ti[i]) 
		f[i][j] = max(f[i][j], f[i - 1][j - ti[i]] + pri[i]) ;
```
>## 4.输出答案

##　代码实现
```cpp
#include
using namespace std ;
int ti[1005] , pri[1005] ;
int f[1005][1005] ;
int main()
{
	int t , m ;
	cin >> t >> m ;
	for(int i = 1 ; i <= m ; ++i)
	{
		cin >> ti[i] >> pri[i] ;
        for(int j = 1 ; j <= t ; ++j)
		{
			f[i][j] = f[i - 1][j] ;
            if(j >= ti[i]) 
				f[i][j] = max(f[i][j], f[i - 1][j - ti[i]] + pri[i]) ;
        }
    }
    cout << f[m][t] ;
	return 0 ;
}
```
## 思路(2 \/ 2)
>## 1.相比于第一种思路,最大的不同就是使用的是一维数组而不是二维数组,不记录i，只记录花费的时间j，其他的都与二维数组的思路没有什么太大的不同

##　代码实现
```cpp
#include
using namespace std ;
int ti[1005] , pri[1005] ;
int f[1005] ;
int main()
{
    int t , m ;
    cin >> t >> m ;
    for(int i = 1 ; i <= m ; ++i)
        cin >> ti[i] >> pri[i] ;
    for(int i = 1 ; i <= m ; ++i)
        for(int j = t ; j >= 1 ; --j)
            if(j >= ti[i])
                f[j] = max(f[j] , f[j - ti[i]] + pri[i]) ;
    cout << f[t] ;
    return 0 ;
}
```




","type":"题解","status":2,"postTime":1565512889,"author":{"uid":99729,"name":"TYX180129","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":62,"commentCount":18,"currentUserVoteType":0,"contentDescription":"动态规划-&gt;背包-&gt;01背包
01背包的特点:物品只有一件。想放就放，不想放就别放
思路(1 \/ 2):

1.定义二维数组 , f[i][j]表示采第i株药,花费时间j可以采到的草...","id":157651,"identifier":"p1048-cai-yao-ti-xie","title":"P1048 采药 题解"},{"content":"01背包的模板，直接往里套。

找准状态转移方程即可；

状态转移方程：

**F[i,v]=max{F[i-1,v],F[i-1,v-c[i]]+w[i]}**

后来，我将状态方程简化了，（就如同消除代数式中的同类项一样）

得到：**F[v]=max{f[v],F[v-c[i]]+w[i]}**

最后将F[v]输出

（注意F数组初始化为0，不要写-1,）

代码粘上

```cpp
#include
int max(int a,int b)
{
    if (a>b) return a;
    else return b;
    }
int main()
{
    int f[1000]={0},c[1000],w[1000];
    int n,v,i,j;
    scanf("%d%d",&v,&n);
    for(i=1;i<=n;i++)scanf("%d%d",&c[i],&w[i]);
    for(i=1;i<=n;i++)
    for(j=v;j>=c[i];j--)
    {
        f[j]=max(f[j],f[j-c[i]]+w[i]);
        }
    printf("%d ",f[v]);
    return 0;
    }

```","type":"题解","status":2,"postTime":1505836164,"author":{"uid":9032,"name":"石破天惊","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":66,"commentCount":24,"currentUserVoteType":0,"contentDescription":"01背包的模板，直接往里套。
找准状态转移方程即可；
状态转移方程：
F[i,v]=max{F[i-1,v],F[i-1,v-c[i]]+w[i]}
后来，我将状态方程简化了，（就如同消除代数式...","id":1896,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"## 注意：本题解绝非正解

>~~像_26535_这个被幼儿园吊打的蒟蒻，显然不会DP~~

显然，对于一个学了一年DP也不会的蒟蒻，碰到背包题是相当痛苦的……

然鹅，在窝学会了dfs之后，窝立马去切了若干背包题，发现效果相当之不错

但是，有的背包数据规模感人，以至于dfs无能为力

[例如这一道](https:\/\/www.luogu.org\/record\/22729953)

```cpp
\/\/ luogu-judger-enable-o2
#include
using namespace std;
int t,n,mx;
int a[105],w[105];
inline void dfs(int s,int z,int y)
{
	if(y>t) return;
	if(z==n)
	{
		mx=max(mx,s);
		return;
	}
	dfs(s+w[z],z+1,y+a[z]);
	dfs(s,z+1,y);
}
int main()
{
	cin>>t>>n;
	for(int i=0;i>a[i]>>w[i];
	dfs(0,0,0);
	cout<<mx;
}
```
后来研究了MR（一种基于概率的高性能素数判定算法）许久，终于想出了一种奇葩算法~~虽然有一些骗分的味道~~

如果把“草药”按性价比，即价值除以时间排序，然后取尽量多的前几项，直到没时间为止，那这个贪心策略有什么问题吗？

显然，反例很容易举出：

```
60 3
2 30
29 30
30 31
```
如果按贪心策略，则应该选择30+30=60，但是正解却是30+31=61

所以，我们只能得出结论：**排序后，越靠前被选中的概率越高**

emmmm……所以这能得出什么呢？

如果把算法执行多次，每次对于越靠前的数选中的几率越高（当然也有选不中的可能），然后取多次的最大值！

实测选第i个数的概率函数用

```cpp
rand()%(m-j+1)!=0
```
次数为
```cpp
m*10
```
即可

## 速度不亚于DP！！！

```cpp
#include 
using namespace std;
struct th
{
	int ti,v;
}a[105];
const int S=20;
bool cmp(th x,th y)\/\/性价比较函数
{
	return x.v*y.ti>y.v*x.ti;
}
int main()
{
	srand(time(0));
	int t,m,i,j,mx=0,time,vs;
	cin>>t>>m;
	for(i=0;i>a[i].ti>>a[i].v;
	sort(a,a+m,cmp);
	for(i=0;i<m*S;i++)\/\/多次贪心
	{
		time=t,vs=0;
		for(j=0;j<m;j++)
			if(rand()%(m-j+1)&&a[j].ti<=time)
				time-=a[j].ti,vs+=a[j].v;
		mx=max(mx,vs);\/\/取最大值
	}
	cout<<mx;
} 
```
注：本算法由于具有随机性，可能要提交多次才能通过,如果遇到这种情况，可调大S","type":"题解","status":2,"postTime":1573884893,"author":{"uid":203623,"name":"critnos","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/3atzvvyr.png"},"thumbUp":42,"commentCount":22,"currentUserVoteType":0,"contentDescription":"注意：本题解绝非正解

像_26535_这个被幼儿园吊打的蒟蒻，显然不会DP

显然，对于一个学了一年DP也不会的蒟蒻，碰到背包题是相当痛苦的……
然鹅，在窝学会了dfs之后，窝立马去切了若干背...","id":193353,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"这道题的解法很多，大部分是动态规划和记忆化搜索，但是如果T一旦很大的话，动态规划和记忆化搜索会被卡掉。那我们有没有别的方法呢？是有的。

下面隆重介绍：

# 启发式搜索

启发式搜索是在暴力DFS基础上进行剪枝的搜索。你可能会说，不就是剪了一点枝吗，会快很多吗？答案是会。

我们先说一下，所有的启发式搜索都会有一个估价函数。下面是这一题的估价函数。

```cpp
struct node
{
	int c,v;
	double cost;
};
const int N=10000;
node a[N+5];
inline int f(int t,int v)
{
	int tot=0;
	for(int i=1;t+i<=n;i++)
	{
		if(v>=a[t+i].c)
		{
			v-=a[t+i].c;
			tot+=a[t+i].v;
		}
		else return (int) (tot+v*a[t+i].cost);
	}
	return tot;
}
```

那么估价函数是什么呢？我们都知道，背包问题的最基础的思路是O(2^n)。一个状态有两种决策，分别是取和不取，那么，我们在取的时候判断一下是不是超过了体积，在不取的时候判断一下，如果，我不取这个，那么，剩下的所有的价值+现有的价值有没有大于我所找到的目前的最优解，如果没有，不取是没有意义的。听不懂？没关系。我们先上核心代码。

```cpp
void DFS(int now,int cv,int cp)
{
	ans=code::max(ans,cp);
	if(now>n) {return;}
	if(f(now,cv)+cp>ans) DFS(now+1,cv,cp);
	if(cv-a[now].c>=0) DFS(now+1,cv-a[now].c,cp+a[now].v);
}
```

假设，我现在的最优解是2，如果我不取这个物品，所能得到的估价比这个小，说明不取是没有意义的，因为就算你剩下的全部取了都不是最优解。那么，估价有没有可能估小了呢？不可能。

```cpp
bool operator <(const node &a,const node &b)
{
	return a.cost>b.cost;
}
sort(a+1,a+1+n);
```

上面这段代码就保证了不可能估小。以及，我们在估价时，不管它到底可不可以放进去，只有背包有空间，就放，而放的价值就是单位价值：

```cpp
	a[i].cost=1.0*a[i].v\/a[i].c
```

好的，我们现在就放出完整代码。

(本题思路来自我的老师宋力强，代码均由本人实现)

```cpp
#include 
#include 
#include 
int n, tot, ans;
struct node
{
    int c, v;
    double cost;
};
using namespace std;
const int N = 10000;
node a[N + 5];
int read() \/*快读大法吼啊！*\/
{
    int x = 0;short w = 0;char ch = 0;
    while (!isdigit(ch)){w |= ch == '-';ch = getchar();}
    while (isdigit(ch)){x = (x << 3) + (x << 1) + (ch ^ 48);ch = getchar();}
    return w ? -x : x;
}
inline int f(int t, int v) \/\/估价函数，解释见上。
{
    int tot = 0;
    for (int i = 1; t + i <= n; i++)
    {
        if (v >= a[t + i].c)
        {
            v -= a[t + i].c;
            tot += a[t + i].v;
        }
        else
            return (int)(tot + v * a[t + i].cost);
    }
    return tot;
}
bool operator<(const node &a, const node &b)
{
    return a.cost > b.cost;
} \/*等价于
bool cmp(node a,node b)
{
    return a.cost>b.cost;
}
*\/
void DFS(int now, int cv, int cp)
{
    ans = max(ans, cp);
    if (now > n)
    {
        return;
    }
    if (f(now, cv) + cp > ans)
        DFS(now + 1, cv, cp);
    if (cv - a[now].c >= 0)
        DFS(now + 1, cv - a[now].c, cp + a[now].v);
}
int main()
{
    tot = read(), n = read();
    for (int i = 1; i <= n; i++)
    {
        a[i].c = read(), a[i].v = read();
        a[i].cost = 1.0 * a[i].v \/ a[i].c;
    }
    sort(a + 1, a + 1 + n);
    DFS(0, tot, 0);
    printf("%d", ans);
    return 0;
}
```

update:2020\/5\/2 将对新手不友好的语法改成了最朴素的写法","type":"题解","status":2,"postTime":1544714625,"author":{"uid":96340,"name":"AC机","slogan":"十香永远在我心中","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/p2v51sdd.png"},"thumbUp":41,"commentCount":28,"currentUserVoteType":0,"contentDescription":"这道题的解法很多，大部分是动态规划和记忆化搜索，但是如果T一旦很大的话，动态规划和记忆化搜索会被卡掉。那我们有没有别的方法呢？是有的。
下面隆重介绍：
启发式搜索
启发式搜索是在暴力DFS基础上...","id":95986,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"看到dalao都用动态规划感到十分复杂，我想把深度优先搜索简化一下，就会使时间复杂度和动态规划一样，这样好理解……

不多说，代码

```cpp
#include
#include\/\/头文件
using namespace std;
int f[105][1005];\/\/数组一定要多开几个，不然WA
int m,n,mi[105],vi[105];
int dfs(int x,int sumW)\/\/把一个参数作为该函数的函数类型（优化一）
    {
    if(sumW>m)return -10000;\/\/时间不能超出欧！
    if(f[x][sumW]) return f[x][sumW];\/\/用一个数组来储存每一次dfs的数值，避免重复（优化二）
    if(x==n+1) return 0;\/\/到末尾了就返回0
    f[x][sumW]=max(dfs(x+1,sumW+mi[x])+vi[x],dfs(x+1,sumW));\/\/取最大值，没啥好说的
    return f[x][sumW];\/\/输出最大值
}
int main(){
    cin>>m>>n;
    for(int i=0;i>mi[i]>>vi[i];
    }
    cout<<dfs(0,0)<<endl;
    return 0;
}
```","type":"题解","status":2,"postTime":1500377794,"author":{"uid":45338,"name":"三青鸟之翎","slogan":"u1s1，我好弱啊..","badge":null,"isAdmin":false,"isBanned":false,"color":"Orange","ccfLevel":8,"background":""},"thumbUp":35,"commentCount":5,"currentUserVoteType":0,"contentDescription":"看到dalao都用动态规划感到十分复杂，我想把深度优先搜索简化一下，就会使时间复杂度和动态规划一样，这样好理解……
不多说，代码
","id":1887,"identifier":"solution-p1048","title":"题解 P1048 【采药】"},{"content":"### 这几乎是一道和01背包例题一模一样的水题！！！


动态规划是一种强大的计算模式，其解决问题的方式是首先定义一组子问题，按照从小问题解决大问题的模式，依次解决所有子问题并最终求解原问题。
所以我们来回顾一下

#### 步骤

第一步：确定子问题。 在这一步重点是分析那些变量是随着问题规模的变小而变小的， 那些变量与问题的规模无关。 

第二步：确定状态：根据上面找到的子问题来给你分割的子问题限定状态

第三步：推到出状态转移方程：这里要注意你的状态转移方程是不是满足所有的条件， 注意不要遗漏。 

第四步：确定边界条件：先根据题目的限制条件来确定题目中给出的边界条件是否能直接推导出， 如果不行也可以尝试从边界条件反推（举个例子：a(n)→a(2)有递推关系， 但是a(2)→a(1)不符合上述递推关系， 我们就可以考虑用a(1)来倒推出a(2)， 然后将递推的终点设置为a(2)）; 

第五步：确定实现方式：这个依照个人习惯 就像是01背包的两层for循环的顺序 

第六步：确定优化方法：很多时候你会发现走到这里步的时候你需要返回第1步重来。首先考虑降维问题（优化内存）， 优先队列、四边形不等式（优化时间）等等。



#### 几个背包的模板

1.无优化
```cpp
for(int i=1;i<=n;i++){  
	for(int j=1;j<=m1;j++){   
		if(j>=t[i]){
        f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]);
		}
		else{
			f[i][j]=f[i-1][j];
		}
	}
}
```
2.空间优化

```cpp
for(int i=1;i<=n;i++){  
	for(int j=m;j>=0;j--){  \/\/--是为了防止叠加 
		if(j>=w[i]){  
		 	f[j]=max(f[j],f[j-w[i]]+c[i]);
		}	 
	}
}
```
3.常数优化
```cpp
for(int i=1;i<=n;i++){
    sum+=w[i];
    b=max(m-sum,w[i]);
    for(int j=m;j>=bound;j--){
		if(j>=w[i]){
  			f[j]=max(f[j],f[j-w[i]]+c[i]);
  		}
  	  }
}
```
4.完全背包

```
for(int i=1;i<=n;i++){  
		for(int j=0;j<=m;j++){  
			if(j>=w[i]){  
				f[j]=max(f[j],f[j-w[i]]+c[i]);
			}	 
		}
	}
```

### 回到正题
这道题吧，本蒟蒻认为用最简单的无优化版二维数组就可以，当然空间优化的也可以。

### 状态转移方程：
1.无优化版```cpp
f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]); ```

2.空间优化版
```cpp
f[j]=max(f[j],f[j-w[i]]+c[i]);
```

所以，上源代码。

1.最简单的
```cpp
int t[1001],m[101],f[1001][1001];  \/\/t:时间  m:草药数量 
int main(){
	int m1,n;
	cin>>m1>>n;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>m[i];
	} 
	for(int i=1;i<=n;i++){  \/\/时间 
		for(int j=1;j<=m1;j++){  \/\/数目 
			if(j>=t[i]){
				f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]);
			}
			else{
				f[i][j]=f[i-1][j];
			}
		}
	}
	cout<>m>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>c[i];
	}
	for(int i=1;i<=n;i++){  \/\/循环物品 
		for(int j=m;j>=0;j--){  \/\/循环容量,--是为了防止叠加 
			\/\/判断当前物品是否可以放入包中
			if(j>=w[i]){   \/\/能放进去的话就判断哪一种价值大 
				f[j]=max(f[j],f[j-w[i]]+c[i]);\/\/状态转移方程 
			}	 
		}
	}
	cout<=w[i])$$

为什么呢？

想一想就明白，max内第一项是指不选这个物品，为这个重量的最大值  
而第二项是选这个物品，从$j-w[i]$这个重量加上当前重量$w[i]$的最大值加上本次选的物品的价值

听起来可能有点绕哈，多读几遍其实就懂了

那么，本次介绍的是一维数组（会的大佬请移步）

我们将$f$数组降成一维，还好写一点~~（什么玄学东西）~~

改进一下思路，如果我们以$f[j]$储存原来的$f[i][j]$，是否可行呢？

想想，原来我们的最大值是由$f[i-1][j],f[i-1][j-w[i]]+c[i]$两个状态中的最大值转移过来的，所以，这个问题就转化成，能否在求$f[i][j]$时就求出了上面两个状态的值？

其实是可以的，但有个细节，一维数组中j的扫描顺序应该从大到小(m到0)，否则前一次循环保存下来的值将会被修改，从而造成错误——变成♂$van$♂全背包

好了，方程推完了，接下来上代码：

```cpp
#include 
using namespace std;
int f[10001],c[10001],w[10001],n,t;
int main()
{
	scanf("%d %d",&n,&t);
	for(int i=1;i<=t;i++)
		scanf("%d %d",&w[i],&c[i]);
	for(int i=1;i<=t;i++)
		for(int j=n;j>=w[i];j--)
			if(f[j]<f[j-w[i]]+c[i])
				f[j]=f[j-w[i]]+c[i];
	printf("%d",f[n]);
	return 0;
}
```","type":"题解","status":2,"postTime":1548836690,"author":{"uid":112395,"name":"Martin_MHT","slogan":"AFOed。","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":""},"thumbUp":19,"commentCount":11,"currentUserVoteType":0,"contentDescription":"前言
这篇题解我是觉得，没啥希望过（因为优质题解已经很多了，而且我这个蒟蒻写的也一般般），所以只要是写给自己复习一下的（当然能过我更开心）
正题
其实这道题就是裸01背包
so，我们先从普通的0...","id":108032,"identifier":"solution-p1048","title":"题解 P1048 【采药】"}],"perPage":10,"count":56},"problem":{"pid":"P1048","title":"[NOIP2005 普及组] 采药","difficulty":2,"fullScore":100,"type":"P"},"acceptSolution":false},"currentTitle":"题解","currentTheme":{"id":559,"header":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-63,"degree":244,"repeat":0,"position":[50,17],"size":[1,1],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"},"sideNav":{"logoBackgroundColor":[23,208,180,1],"color":[255,64,122,1],"invertColor":false,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\SideNavConfig"},"footer":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-2,"degree":0,"repeat":0,"position":[38,73],"size":[0,0],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"}},"currentTime":1694532658,"currentUser":{"followingCount":0,"followerCount":0,"ranking":null,"eloValue":null,"blogAddress":null,"unreadMessageCount":0,"unreadNoticeCount":0,"uid":570994,"name":"kkRookie","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"","verified":true}}"));window._feConfigVersion=1694162564;window._tagVersion=1694530844;