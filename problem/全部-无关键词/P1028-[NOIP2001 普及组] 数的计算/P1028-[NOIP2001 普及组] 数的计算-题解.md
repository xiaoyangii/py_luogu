window._feInjection = JSON.parse(decodeURIComponent("{"code":200,"currentTemplate":"ProblemSolution","currentData":{"solutions":{"result":[{"content":"----------------------------

**十分激动的第一次发题解**


不说多了，直接开始:

我们以4为例子来进行说明

4后面可以跟上1,2组成14,24

14后面跟不了,24可以跟上1组成124

再加上4本身就可以得到4的种类

即 14,24,124,4

而我们只要算出1,2的种类就可以加起来得到4的种类

**因此，我们得到

```cpp
f[1]=1
f[2]=2=f[1]+1
f[3]=2=f[1]+1
f[4]=4=f[1]+f[2]+1
f[5]=4=f[1]+f[2]+1
```
......**
以此类推，我们得到以下代码



------------------------



```cpp
#include\/\/万能头文件
using namespace std;
int n;
int f[1001];\/\/存每一位数的种类
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){ \/\/1-n的递推
        for(int j=1;j<=i\/2;j++){
            f[i]+=f[j]; \/\/每一位叠加，递推走起
        }
        f[i]++; \/\/加上本身
    }
    cout<<f[n];\/\/输出n的种类
    return 0;
}
```
------------

总体来说，这道题是数学思想以及对递推的理解，自己推导一下还是做的出来。


最后希望各位大犇指出不足，多多包涵。
","type":"题解","status":2,"postTime":1514099796,"author":{"uid":64195,"name":"L_OnceL","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":1326,"commentCount":255,"currentUserVoteType":0,"contentDescription":"
十分激动的第一次发题解
不说多了，直接开始:
我们以4为例子来进行说明
4后面可以跟上1,2组成14,24
14后面跟不了,24可以跟上1组成124
再加上4本身就可以得到4的种类
即 14,...","id":19832,"identifier":"solution-p1028","title":"只能说是递推"},{"content":"**UPD:远古时期写的题解，当时本人比较sb，看的时候不必太较**真。。。

**  第一次发题解的蒟蒻**
  
  ****
  
  题目链接： [P1028 【数的计算】](https:\/\/www.luogu.org\/problemnew\/show\/P1028)
  
  ****
  
 ** 变态打表**
 
 ————oi中的得分神器
  
  


------------

------------
      打表法就是将题目中需要的答案集合提前算出来，存到代码里，根据题目所需取答案，这种方法通常只需要将程序挂着，在表打完后进行加工，最终取答案程序时间复杂度为O(1)，空间复杂度为O(n)(n为答案规模)； 
                         ——沃兹·基朔德
  
  

------------


------------

**  1.**
  
  打表之前先要把所有数据搜出来，用个笨搜索慢慢搜，我大约搜了10多分钟————看代码
  
   ```cpp
#include 
#include 
using namespace std;
long long dfs(int x) \/\/深搜
{
	if(x==1) return 1;
	long long tot=1; \/\/加上自身，所以初始化是 1 
	for(int i=1;i<=x\/2;i++) \/\/列举 
		tot+=dfs(i);
	return tot;
}
int main()
{
	cout<<"a[1001]={";  \/\/便于直接复制 
	for(int i=1;i<=1000;i++) \/\/枚举所有数 
	{
		cout<<dfs(i)<<",";
	}
	cout<<"}";
}
```

这个应该很好理解，不讲了，运行结果记得复制。

**2.**

打表时几点注意事项：

1.每行都要敲回车，不然会编译错误

2.数组开头补0
```cpp 
#include
using namespace std;
int main(){
	int n;
	cin>>n;
	\/*以下为打表核心，可能要费力敲一下回车*\/ 
    int a[1003]={0,1,2,2,4,4,6,6,10,10,14,14,20,20,26,26,36,36,46,46,60,60,74,74,94,94
    ,114,114,140,140,166,166,202,202,238,238,284,284,330,330,390,390,450,450,524,
    524
    ,598,598,692,692,786,786,900,900,1014,1014,1154,1154,1294,1294,1460,1460,1626,
    1626,1828,1828,2030,2030,2268,2268,2506,2506,2790,2790,3074,3074,3404,3404,3734,
    3734,4124,4124,4514,4514,4964,4964,5414,5414,5938,5938,6462,6462,7060,7060,7658,
    7658,8350,8350,9042,9042,9828,9828,10614,10614,11514,11514,12414,12414,13428,
    13428
    ,14442,14442,15596,15596,16750,16750,18044,18044,19338,19338,20798,20798,22258,
    22258,23884,23884,25510,25510,27338,27338,29166,29166,31196,31196,33226,33226,
    35494,35494,37762,37762,40268,40268,42774,42774,45564,45564,48354,48354,51428,
    51428
    ,54502,54502,57906,57906,61310,61310,65044,65044,68778,68778,72902,72902,77026,
    77026,81540,81540,86054,86054,91018,91018,95982,95982,101396,101396,106810,106810
    ,112748,112748,118686,118686,125148,125148,131610,131610,138670,138670,145730,
    145730,153388,153388,161046,161046,169396,169396,177746,177746,186788,186788,
    195830,195830,205658,205658,215486,215486,226100,226100,236714,236714,248228,248228,
    259742,259742,272156,272156,284570,284570,297998,297998,311426,311426,325868,
    325868,340310,340310,355906,355906,371502,371502,388252,388252,405002,405002,423046,
    423046,441090,441090,460428,460428,479766,479766,500564,500564,521362,521362,
    543620,543620,565878,565878,589762,589762,613646,613646,639156,639156,664666,664666
    ,692004,692004,719342,719342,748508,748508,777674,777674,808870,808870,840066,
    840066,873292,873292,906518,906518,942012,942012,977506,977506,1015268,1015268,
    1053030,1053030,1093298,1093298,1133566,1133566,1176340,1176340,1219114,1219114,
    1264678,1264678,1310242,1310242,1358596,1358596,1406950,1406950,1458378,1458378,
    1509806,1509806,1564308,1564308,1618810,1618810,1676716,1676716,1734622,1734622,
    1795932,1795932,1857242,1857242,1922286,1922286,1987330,1987330,2056108,2056108,
    2124886,2124886,2197788,2197788,2270690,2270690,2347716,2347716,2424742,2424742,
    2506282,2506282,2587822,2587822,2673876,2673876,2759930,2759930,2850948,2850948,
    2941966,2941966,3037948,3037948,3133930,3133930,3235326,3235326,3336722,3336722,
    3443532,3443532,3550342,3550342,3663090,3663090,3775838,3775838,3894524,3894524,
    4013210,4013210,4138358,4138358,4263506,4263506,4395116,4395116,4526726,4526726,
    4665396,4665396,4804066,4804066,4949796,4949796,5095526,5095526,5248914,5248914,
    5402302,5402302,5563348,5563348,5724394,5724394,5893790,5893790,6063186,6063186,
    6240932,6240932,6418678,6418678,6605466,6605466,6792254,6792254,6988084,6988084,
	7183914,7183914,7389572,7389572,7595230,7595230,7810716,7810716,8026202,8026202,
	8252302,8252302,8478402,8478402,8715116,8715116,8951830,8951830,9200058,9200058,
	9448286,9448286,9708028,9708028,9967770,9967770,10239926,10239926,10512082,10512082,
	10796652,10796652,11081222,11081222,11379220,11379220,11677218,11677218,
    11988644,11988644,12300070,12300070,12625938,12625938,12951806,12951806,13292116,
    13292116,13632426,13632426,13988332,13988332,14344238,14344238,14715740,14715740,
	15087242,15087242,15475494,15475494,15863746,15863746,16268748,16268748,16673750,
	16673750,17096796,17096796,17519842,17519842,17960932,17960932,18402022,18402022,
	18862450,18862450,19322878,19322878,19802644,19802644,20282410,20282410,20782974,
	20782974,21283538,21283538,21804900,21804900,22326262,22326262,22869882,22869882,
	23413502,23413502,23979380,23979380,24545258,24545258,25135020,25135020,25724782,
	25724782,26338428,26338428,26952074,26952074,27591230,27591230,28230386,28230386,
	28895052,28895052,29559718,29559718,30251722,30251722,30943726,30943726,31663068,
	31663068,32382410,32382410,33130918,33130918,33879426,33879426,34657100,
    34657100,35434774,35434774,36243644,36243644,37052514,37052514,37892580,37892580,
    38732646,38732646,39605938,39605938,40479230,40479230,41385748,41385748,42292266,
	42292266,43234278,43234278,44176290,44176290,45153796,45153796,46131302,46131302,
	7146570,47146570,48161838,48161838,49214868,49214868,50267898,50267898,51361196,
	51361196,52454494,52454494,53588060,53588060,54721626,54721626,55897966,55897966,
	57074306,57074306,58293420,58293420,59512534,59512534,60777212,60777212,62041890,
    62041890,63352132,63352132,64662374,64662374,66020970,66020970,67379566,67379566
    ,68786516,68786516,70193466,70193466,71651844,71651844,73110222,73110222,74620028,
	74620028,76129834,76129834,77694142,77694142,79258450,79258450,80877260,80877260,
	82496070,82496070,84172786,84172786,85849502,85849502,87584124,87584124,89318746,
	89318746,91114678,91114678,92910610,92910610,94767852,94767852,96625094,96625094,
	98547380,98547380,100469666,100469666,102456996,102456996,104444326,104444326,106500434,
	106500434,108556542,108556542,110681428,110681428,112806314,112806314,115004102,115004102,
	117201890,117201890,119472580,119472580,121743270,121743270,124090986,124090986,126438702,
	126438702,128863444,128863444,131288186,131288186,133794468,133794468,136300750,136300750,
	138888572,138888572,141476394,141476394,144150270,144150270,146824146,146824146,149584076,
	149584076,152344006,152344006,155194954,155194954,158045902,158045902,160987868,160987868,
	163929834,163929834,166967782,166967782,170005730,170005730,173139660,173139660,176273590,
	176273590,179508916,179508916,182744242,182744242,186080964,186080964,189417686,189417686,
	192861218,192861218,196304750,196304750,199855092,199855092,203405434,203405434,207068524,
	207068524,210731614,210731614,214507452,214507452,218283290,218283290,222177814,222177814,
	226072338,226072338,230085548,230085548,234098758,234098758,238237116,238237116,242375474,
	242375474,246638980,246638980,250902486,250902486,255297602,255297602,259692718,259692718,
	264219444,264219444,268746170,268746170,273411566,273411566,278076962,278076962,282881028,
	282881028,287685094,287685094,292634890,292634890,297584686,297584686,302680212,302680212,
	307775738,307775738,313024652,313024652,318273566,318273566,323675868,323675868,329078170,
	329078170,334641518,334641518,340204866,340204866,345929260,345929260,351653654,351653654,
	357547444,357547444,363441234,363441234,369504420,369504420,375567606,375567606,381808538,
	381808538,388049470,388049470,394468148,394468148,400886826,400886826,407492292,407492292,
	414097758,414097758,420890012,420890012,427682266,427682266,434670350,434670350,441658434,
	441658434,448842348,448842348,456026262,456026262,463415834,463415834,470805406,470805406,
	478400636,478400636,485995866,485995866,493806582,493806582,501617298,501617298,509643500,
	509643500,517669702,517669702,525922004,525922004,534174306,534174306,542652708,542652708,
	551131110,551131110,559846226,559846226,568561342,568561342,577513172,577513172,586465002,
	586465002,595665060,595665060,604865118,604865118,614313404,614313404,623761690,623761690,
	633469718,633469718,643177746,643177746,653145516,653145516,663113286,663113286,673353212,
	673353212,683593138,683593138,694105220,694105220,704617302,704617302,715413954,715413954,
	726210606,726210606,737291828,737291828,748373050,748373050,759752270,759752270,771131490,
	771131490,782808708,782808708,794485926,794485926,806474570,806474570,818463214,818463214,
	830763284,830763284,843063354,843063354,855689292,855689292,868315230,868315230,881267036,
	881267036,894218842,894218842,907510958,907510958,920803074,920803074,934435500,934435500,
	948067926,948067926,962056258,962056258,976044590,976044590,990388828,990388828,1004733066
	,1004733066,1019448806,1019448806,1034164546,1034164546,1049251788,1049251788,1064339030,
	1064339030,1079814524,1079814524,1095290018,1095290018,1111153764,1111153764,1127017510,
	1127017510,1143286258,1143286258,1159555006,1159555006,1176228756,1176228756,1192902506,
	1192902506,1209999302,1209999302,1227096098,1227096098,1244615940,1244615940,1262135782,
	1262135782,1280096714,1280096714,1298057646,1298057646,1316459668,1316459668,1334861690,
	1334861690,1353724140,1353724140,1372586590,1372586590,1391909468,1391909468,1411232346,
	1411232346,1431034990,1431034990,1450837634,1450837634,1471120044,1471120044,1491402454,
	1491402454,1512185428,1512185428,1532968402,1532968402,1554251940,1554251940,1575535478,
	1575535478,1597340378,1597340378,1619145278,1619145278,1641471540,1641471540,1663797802,
	1663797802,1686667684,1686667684,1709537566,1709537566,1732951068,1732951068,1756364570,
	1756364570,1780343950,1780343950,1804323330,1804323330,1828868588,1828868588,1853413846,
	1853413846,1878548866,1878548866,1903683886,1903683886,1929408668,1929408668,1955133450,
	1955133450,1981471878,1981471878,2007810306};
    cout<<a[n];    \/\/直接输出 
    return 0;
}
```


****

****
** 感谢[LYR大佬](https:\/\/www.luogu.org\/space\/show?uid=84068)提供的帮助**","type":"题解","status":2,"postTime":1541170650,"author":{"uid":84066,"name":"Mcggvc","slogan":"鸣神の　少しとよみて　さし昙り　雨も降らんか　君を留めん","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/2dc96oc6.png"},"thumbUp":680,"commentCount":494,"currentUserVoteType":0,"contentDescription":"UPD:远古时期写的题解，当时本人比较sb，看的时候不必太较真。。。
  第一次发题解的蒟蒻

题目链接： P1028 【数的计算】

 变态打表
————oi中的得分神器





  1...","id":84376,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"好吧，这道题有两种解法

第一种估计是大家一下子就想到的：

暴力递归！！（很明显不是正解）

粘一个我的代码

```cpp
#include
using namespace std;
int n,cnt=1;
void func(int x){
    for(int i=1;i<=x\/2;i++){
        cnt++;
        func(i);
    }
}
int main(){
    scanf("%d",&n);
    func(n);
    printf("%d\n",cnt);
}
```
这个递归大概能骗过n=500，然而题目中是n<=1000
所以正解肯定不是暴力

正解其实是递推（也可以说是简单DP）

先粘个代码再解释

```cpp
#include
using namespace std;
int main(){
    int n,cnt=1,i,f[1010];
    f[0]=f[1]=1;
    scanf("%d",&n);
    for(i=2;i<=n;i++){
        if(i%2==0){
            f[i]=f[i-1]+f[i\/2];
        }else{
            f[i]=f[i-1];
        }
    }
    printf("%d\n",f[n]);
}
```
在打代码之前，我们不妨手动模拟一下
```cpp
n=0,n=1时，答案显然是1
n=2, ans=2;    n=3,ans=2
n=4,ans=4;    n=5,ans=4
n=6,ans=6;    n=7,ans=6
```
相信大家也发现了，2n与2n+1(n为非负整数)的答案是一样的
这就是第一个规律

然后我们以n=8为例，手动模拟一下

一共有10组解

8
1 8            2 8            3 8            4 8

1 2 8            1 3 8        1 4 8        2 4 8

1 2 4 8

我打出的东西很像一棵搜索树。。。

当我们把8和8下面的左三棵子树放在一起（即8和下面三列），并将所有的8都改成7，我们能发现，我们得到了n=7时的所有解；

我们再把最右端的子树（即剩下的部分）中的所有8删去，我们得到了n=4时的所有解

就这样，我们可以得到一个递推式，

        f(n)=f(n-1)                \/\/7=8-1

            +f(n\/2)                \/\/4=8\/2

再结合之前发现的规律

就能得到：

```cpp
n%2==0时
    f(n)=f(n-1)+f(n\/2)
n%2==1时
    f(n)=f(n-1)
然后问题就迎刃而解啦
```","type":"题解","status":2,"postTime":1471160157,"author":{"uid":21903,"name":"vegetabird","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":""},"thumbUp":495,"commentCount":135,"currentUserVoteType":0,"contentDescription":"好吧，这道题有两种解法
第一种估计是大家一下子就想到的：
暴力递归！！（很明显不是正解）
粘一个我的代码

这个递归大概能骗过n=500，然而题目中是n&lt;=1000
所以正解肯定不是暴力
...","id":1471,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"## Code $O(n)$

### Force 25% $O(n^n)$

递归是过不了的。。与Fibonacci相似。可以分析递归复杂度。

$(n) = \sum_{i=1}^{n\/2}f(i)+o(1)$

求上界的话，放缩一下：

$f(n) = nf(n-1)+o(1)$

显然，递推一下就有（$n!=O(n^n)$），比指数还吓人。。

$f(n) = O(n^n)$

```c++
#include 
using namespace std;

int f(int n){
    if(n == 1) return 1;
	int result = 0;
    for(int i = 1; i <= n\/2; ++i)  \/\/通项
        result += f(i);
    return result + 1;  \/\/算上自己
}

int main(){
    int n; cin>>n;
    cout<<f(n);
}
```

### Force+记忆剪枝 $O(n^2)+O(n)$

```c++
#include 
using namespace std;

int f_remember[1005];

int f(int n){
    if(n == 1) return 1;
	if(f_remember[n]) return f_remember[n];
	int result = 0;
    for(int i = 1; i <= n\/2; ++i)
        result += f(i);
    return f_remember[n] = result + 1;  \/\/记忆
}

int main(){
    int n; cin>>n;
    cout< 此方法相当于记忆剪枝的迭代版改写。


状态方程：（先求小，再求大）

$f(n) = \sum_{i=1}^{n\/2}f(i), f(1)=1$

注意到从递推式的基本项可以向上**传播**。
```c++
#include 
using namespace std;

int f[1005];

int main(){
    int n; cin>>n;
    f[1] = 1;
    for(int i = 2; i <= n; ++i){
        for(int j = 1; j <= i\/2; ++j)  \/\/通项
            f[i] += f[j];
        f[i] ++;  \/\/算上自己
    }
    cout< 显然每一步的**求和**中，**存在大量的重复计算**。

递推公式可以优化为：

$f(n) = SUM(n\/2)+1,\quad SUM(i) = SUM(i-1)+f(i)$

这时内部求和的$O(n)$变为分摊常数。同样可以采用递归或迭代方法。

#### 记忆剪枝 $O(n)+O(n)$

```c++
#include 
using namespace std;

int f[1005], sum[505];

int F(int i); int Sum(int i);

int main(){
    int n; cin>>n;
    f[1] = sum[1] = 1;
    cout<<F(n);
}

int F(int i){
    if(f[i]) return f[i]; \/\/剪枝
    return f[i] = Sum(i\/2) + 1;  \/\/利用赋值，记忆
}

int Sum(int i){
    if(sum[i]) return sum[i]; \/\/剪枝
    return sum[i] = Sum(i - 1) + F(i);  \/\/利用赋值，记忆
}
```

#### 迭代传播 $O(n)+O(n)$

```c++
#include 
using namespace std;

int f[1005], sum[505];

int main(){
    int n; cin>>n;
    f[1] = 1;
    for(int i = 2; i <= n; ++i){
        sum[i\/2] = sum[i\/2 - 1] + f[i\/2];
        f[i] = sum[i\/2] + 1;
    }
    cout< 前面两种的空间准确来讲其实是$O(n)+O(1.5n)$。通过就地可以进行空间优化。
>
> 理论上任何传播算法都可以做到就地，因为每一状态都只与**紧邻的前一状态**有关。
>
> 由于本题的**两个<\/font>**传播公式**相互耦合**，同时实现两个状态的就地传播是**不可能的**。
>
> > 可以理解为：当`i`取值较大时，`sum`的某一项`sum[i]`可以传播到`f`相对很远的两项`f[2i],f[2i+1]`，为了之后计算`sum[2i]`和`sum[2i+1]`，`f`的两项必须被动态缓存起来。可以预见，最多的缓存项可以达到$n\/4$的规模。
>
> 但是，`sum`和`f`**分别的就地传播**，两种方案都可行。如下图所示：

![](https:\/\/i.imgur.com\/FYFPuoj.png)

再关注一下递推公式：

$f(n) = SUM(n\/2)+1,\quad SUM(i) = SUM(i-1)+f(i)$

于是我们可以由此写就地传播辣~～

##### **sum就地**： $O(n)+O(1.0n)$

```c++
#include 
using namespace std;

int f[1005], sum;

int main(){
    int n; cin>>n;
    for(int i = 1; i <= n; i++){
		f[i] = sum + 1;
		if(i%2) sum += f[(i+1)\/2];
	}
    cout<< f[n];
}
```

##### **f就地**： $O(n)+O(0.5n)$

```c++
#include 
using namespace std;

int f, sum[505];

int main(){
    int n; cin>>n;
    for(int i = 1; i <= n\/2; i++){
		f = sum[i\/2] + 1;
		sum[i] = f + sum[i - 1];
	}
    cout<< sum[n\/2] + 1;
}
```

#### 就地+队列 $O(0.5n)+O(0.25n)$

我们之前已经提到，`f`可以用动态缓存的方式记录。并且，每一个`f[i]`的调用都是先进先出的，因此可以采用队列。。

> `sum`只要求到`n\/2`就可以求出`f[n]`，`sum`只要求到`n\/4`就可以求出`f[n\/2]`。
>
> 因此，`sum`求到`n\/4`（此时积累了`n\/4`的缓存），然后卸载缓存到`f[n\/2]`求得`sum[n\/2]`，即可求出`f[n]`。如图：

![Imgur](https:\/\/i.imgur.com\/Ypo0faS.png)

```c++
#include 
using namespace std;

queue f; int sum = 0; \/\/sum[0] = 0

int main(){
    int n; cin>>n;
    int i;
    
    f.push(1);  \/\/initialize f as sum[1]
    for(i = 1; i <= (n >> 2); i++){
		sum += f.front(); f.pop();  \/\/reserve f in queue buffer
		f.push(sum+1); f.push(sum+1);
	}
    for(     ; i <= (n >> 1); i++){
		sum += f.front(); f.pop();  \/\/clear the buffer(maybe 1 element left sometime)
    }

    cout<< sum + 1;
}
```
","type":"题解","status":2,"postTime":1548420255,"author":{"uid":124054,"name":"Vel_","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":354,"commentCount":86,"currentUserVoteType":0,"contentDescription":"Code $O(n)$
Force 25% $O(n^n)$
递归是过不了的。。与Fibonacci相似。可以分析递归复杂度。
$(n) = \sum_{i=1}^{n\/2}f(i)+o(1)$...","id":106119,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"好吧 我承认我以前是用模拟法做的。现在介绍递推法。

设f[i]为初始值为i时的满足条件总数，可得f[i]=f[1]+f[2]+f[3]+...+f[i\/2];容易想到f[1]=1;

因为f[i]=f[1]+f[2]+f[3]+...+f[i\/2]   所以当i为奇数时f[i]=f[i-1],当i为偶数时f[i]=f[i-1]+f[i\/2];

代码如下：

```cpp
[color=red]
#include 
using namespace std;
int f[1001];
int main()
{
    int n;
    cin>>n;
    f[1]=1;
    for(int i=2;i<=n;i++)
    {
            f[i]=f[i-1];
            if(i%2==0)
                f[i]+=f[i\/2];
    }
    cout<<f[n];
    return 0;
} 
[\/color]
```","type":"题解","status":2,"postTime":1465431324,"author":{"uid":15214,"name":"Juliet","slogan":null,"badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":139,"commentCount":41,"currentUserVoteType":0,"contentDescription":"好吧 我承认我以前是用模拟法做的。现在介绍递推法。
设f[i]为初始值为i时的满足条件总数，可得f[i]=f[1]+f[2]+f[3]+...+f[i\/2];容易想到f[1]=1;
因为f[i]...","id":1470,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"
# 数的计算

最近重新看到这道好题，突然发现可以随随便便优化到线性

（注：由于【说明过少】被拒绝了一次，所以改长了一下，求过啊！）

### 先看到题面：

先输入一个自然数 N （ N ≤ 1000 ），然后对此自然数按照如下方法进行处理：

1、不作任何处理；

2、在它的左边加上一个自然数，但该自然数不能超过原数的一半；

3、加上数后，继续按此规则进行处理，直到不能再加自然数为止。

### 这样一道题，我们首先考虑暴搜：

对于一个数，枚举它可以变成什么。

比如 6 ，变成 3 6 ；

如果你对递归有足够的理解，就会发现接下来要处理的相当于一个数字为 3 的子问题，所以可以直接暴力递归。

### 然而暴力递归肯定不大好，所以我们想想怎么优化：

显然对于每个数字，结果是固定的（不论它是原问题还是子问题）。

而且我们只关心方案数而非方案，

所以可以开一个数组来存一下每个数的答案，这样下次访问的时候就只需要读取答案就好了。

也就是记忆化搜索（其实也就是递推）。

### 至于怎么优化到线性呢？

由于 F[i] 是从 F[1] + ... + F[i\/2] + 1 转移过来的

并且 F 数组显然是按顺序求的（也就是说前缀和是不带修改的）

所以用一个前缀和维护一下可以 O(1) 求每个 F 

初值不用设，答案 F[N]

### 为什么不像其他题解那样推式子呢？

当然是因为这(gen)样(ben)简(bu)单(hui)啊！

9 行代码：

```cpp
#include 
using namespace std ;
int N , Ans[1005] , Sum[1005] ;
int mian() {
	scanf("%d",&N);
	for(register int i = 1 ; i <= N ; i++ )
		Sum[i] = Sum[i-1] + ( Ans[i] = Sum[i>>1] + 1 ) ; \/\/ 更新答案并且计入前缀和
	return not printf("%d\n",Ans[N]) ;
}
```

~~谁抄谁CE~~","type":"题解","status":2,"postTime":1486705514,"author":{"uid":23323,"name":"用户已注销","slogan":null,"badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":106,"commentCount":58,"currentUserVoteType":0,"contentDescription":"数的计算
最近重新看到这道好题，突然发现可以随随便便优化到线性
（注：由于【说明过少】被拒绝了一次，所以改长了一下，求过啊！）
先看到题面：
先输入一个自然数 N （ N ≤ 1000 ），然后...","id":1473,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"**题意**：给定一个数n，开始生成数字，可以添加一个数在n的左边（字符串叠加），也可以不添加。循环该操作。n的上限是1000。

示例：n=6时，

| 6 | 1+6 | 2+6 | 3+6 | 1+2+6 | 1+3+6 |
|:-:|:-:|:-:|:-:|:-:|:-:|

**考查**：递推思想。

**思路**：设 $f_n$ 为答案，寻找数列 f 的递推公式。

**分析**：

1. 假设已知 $f_{499}$ 的答案，求 $f_{500}$ 的答案。 很显然，将 n=499 的所有解中的 499 由 500 替代之后，可以得出绝大多数 n=500 的解，下面分析缺少的部分。由于 n=499 第一次添加的数从 1 到 249，而 n=500 第一次添加的数从 1 到 250，因此缺少的部分是 $f_{250}$。
 
2. 假设已知 $f_{500}$ 的答案，求 $f_{501}$ 的答案。将 n=500 的所有解中的 500 由 501 替代之后，可以得出绝大多数 n=501 的解，下面分析缺少的部分。由于 n=500 第一次添加的数从 1 到 250，而 n=501 第一次添加的数也是从 1 到 250，因此不缺少。

3. 递推公式：$f_{2n} = f_{2n-1} + f_{n}$,
 $f_{2n+1} = f_{2n}$




**代码**：

```cpp
#include
using namespace std;

int main(){
	long long a[1001]={1,1};
	for(int i=2; i<=1000; i++){
		if(i%2 == 0) a[i] = a[i-1] + a[i\/2];
		else a[i] = a[i-1];
	}
	int n;
	cin >> n;
	cout << a[n] << endl;
}
```","type":"题解","status":2,"postTime":1542253414,"author":{"uid":153895,"name":"yangtzib","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":44,"commentCount":14,"currentUserVoteType":0,"contentDescription":"题意：给定一个数n，开始生成数字，可以添加一个数在n的左边（字符串叠加），也可以不添加。循环该操作。n的上限是1000。
示例：n=6时，



6
1+6
2+6
3+6
","id":89131,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"递推法：





```cpp
#include
int f[1001]={0,1};
void count(int n)
{
    int i,j;
    for(i=2;i<=n;i++)
    {
        for(j=1;j<=i\/2;j++)
         f[i]=f[i]+f[j];
         f[i]=f[i]+1; 
    }
}
int main()
{
 int n;
 scanf("%d",&n);
 count(n);
 printf("%d",f[n]);
 return 0;
}
```
递归法：

```cpp
#include
int count(int n)
{
   if(n==1)return 1;
   else if(n==2)return 2;
   else if(n%2==1)return count(n-1);
   else return count(n\/2)+count(n-1);     
}
int main()
{
  int n;
  scanf("%d",&n);
  printf("%d\n",count(n));
 return 0;
}

```","type":"题解","status":2,"postTime":1432029263,"author":{"uid":4725,"name":"wannabe","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":""},"thumbUp":49,"commentCount":22,"currentUserVoteType":0,"contentDescription":"递推法：

递归法：
","id":1455,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"这道题目根本不需要递归。如果不用记忆化记忆住原来的子问题避免第二次重新做同一个子问题，时间复杂度将会成为指数级别的。用递推找寻规律自然数的个数，是本题最优的方法（个人拙见）。下面上思考过程。

-----------------------------------防抄袭分割线--------------------------------------------

我们以h[n]为当前i数字的解，为当自然数为1 的时候，左边不能加任何数，因此i=1时候，自然数序列为1；同理可以推出当i=2的时候自然数序列为2 12……可以思考出递推公式。

------------------------------防抄袭分割线-------------------------------------------------------------

方法改进：如果纯粹按照上述方法做，则时间复杂度为O(n^2)，我们还可以改进，

s(x)=h(1)+h(2)+……+h(x);

h(x)=s(x)-s(x-1);

代码如下


```cpp
var n,i:longint;
h,s:array[-1..1000]of longint;\/\/防止数组溢出错误
begin
readln(n);
for i:=1 to n do\/\/递推过程
begin
h[i]:=1+s[i div 2];
s[i]:=s[i-1]+h[i];
end;
writeln(h[n]);
end.

```","type":"题解","status":2,"postTime":1477305013,"author":{"uid":24081,"name":"Hydra_","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":42,"commentCount":14,"currentUserVoteType":0,"contentDescription":"这道题目根本不需要递归。如果不用记忆化记忆住原来的子问题避免第二次重新做同一个子问题，时间复杂度将会成为指数级别的。用递推找寻规律自然数的个数，是本题最优的方法（个人拙见）。下面上思考过程。
-...","id":1472,"identifier":"solution-p1028","title":"题解 P1028 【数的计算】"},{"content":"```
**第一次发题解**
**激动**

--------------------

程序还是很好理解的
用递归模拟就能做
但是......
如果像一个愣头青一样直接暴力编程的话
就算是给你10000ms的时间限制也是不够的
那么我们就需要进行一波简（偷）化（懒）
我们先看看数字8的计算
  8  |    48   
  18 |   148
  28 |   248
 128 |  1248
  38 |         
 138 |      
可以发现
  28 |   248
 128 |  1248
这两段排列中，都包含的2的计算
也就是
   2 |    12
如果不做其他处理
这一步算是重复做了
虽然2的计算只有两步
影响几乎可以忽略
可一旦数据大了
程序就会做很多重复的步骤
所以我们在这里设立一个用于记录的数组a
将数字x的计算存进a[x]中
一旦之前做过了a[x]的计算
后面就可以直接调用
减少递归的步骤
下面我们看看程序

--------------------

program CountNumer(input,output);
 var
  s,i:longint;
  a:array[1..1000]of longint;
 procedure count(s:longint);
  var
   i:longint;

--------------------

  begin
   for i:=1 to s div 2 do        
    if a[i]>1 then inc(a[s],a[i])                  else begin                                          count(i);             
           inc(a[s],a[i])        
          end;                     
   exit
  end;
\/\/如果 a[i]>1 
\/\/说明已经做过 i 的计算
\/\/只要直接调用就行了
\/\/如果 a[i]=1 
\/\/就需要调用过程做 i 的计算存入 a[i] 中
\/\/下一次再遇到 i 的计算
\/\/就可以直接调用
\/\/从而节省很多时间

--------------------

begin
  read(s);
  for i:=1 to s do \/\/因为数本身也要计算在内
   a[i]:=1;        \/\/所以数组赋初值1
  count(s);        
  write(a[s])
 end.
```","type":"题解","status":2,"postTime":1540017049,"author":{"uid":66364,"name":"落魁","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":17,"commentCount":7,"currentUserVoteType":0,"contentDescription":"","id":78446,"identifier":"solution-p1028-666","title":"瞎打的一个标题"}],"perPage":10,"count":38},"problem":{"pid":"P1028","title":"[NOIP2001 普及组] 数的计算","difficulty":2,"fullScore":100,"type":"P"},"acceptSolution":false},"currentTitle":"题解","currentTheme":{"id":559,"header":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-63,"degree":244,"repeat":0,"position":[50,17],"size":[1,1],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"},"sideNav":{"logoBackgroundColor":[23,208,180,1],"color":[255,64,122,1],"invertColor":false,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\SideNavConfig"},"footer":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-2,"degree":0,"repeat":0,"position":[38,73],"size":[0,0],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"}},"currentTime":1694532558,"currentUser":{"followingCount":0,"followerCount":0,"ranking":null,"eloValue":null,"blogAddress":null,"unreadMessageCount":0,"unreadNoticeCount":0,"uid":570994,"name":"kkRookie","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"","verified":true}}"));window._feConfigVersion=1694162564;window._tagVersion=1694530844;