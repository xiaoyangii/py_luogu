window._feInjection = JSON.parse(decodeURIComponent("{"code":200,"currentTemplate":"ProblemSolution","currentData":{"solutions":{"result":[{"content":"### 前导
这一题让我想到了一个叫做汉诺塔的东西。  
那么，本题可以模拟，但其实不用模拟，因为仔细想可以发现规律的存在。  
### 题目大意
共有 $4$ 根柱子，第四根柱子有 $N$ 个圆片，可以弹出某跟柱子上顶部的圆片然后放在其他主子的顶部，问需要几步完成。  
### 递推（~~打表~~）思想求解
我们先把 $1$ 至 $10$ 的答案列出来，做成数表 $A$：
```
1 3 5 9 13 17 25 33 41 49
```
乍一看似乎没规律，其实有。  

建立一个新数表 $B$，设 $B_1=1$，$B_i(i \geq 2)=A_i-A_{i-1}$ 即步数之差。

有什么用？看就知道了：
```
1 2 2 4 4 4 8 8 8 8
```
一下子变成了简简单单的二重规律数组。

数一下，$1$、$2$、$4$、$8$ 这几个数字出现的次数分别为 $1$、$2$、$3$、$4$，以此类推。

### 代码

```cpp
#include 
using namespace std;
long long n,ans,i,j;
int main(){
	cin>>n;
	for(i=1,j=1;i<=n;i++,j=(j*2)%1000007) {n-=i;ans=(ans+i*j)%1000007;}
	cout<<(ans+n*j)%1000007;
	return 0;
}
```
### **特别提醒：不开 $\tt long$ $\tt long$ 见祖宗**","type":"题解","status":2,"postTime":1658654371,"author":{"uid":540363,"name":"A_Passing_Creeper","slogan":"不蓝钩不改个签，学术了","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/ln7uw9ky.png"},"thumbUp":32,"commentCount":15,"currentUserVoteType":0,"contentDescription":"前导
这一题让我想到了一个叫做汉诺塔的东西。
那么，本题可以模拟，但其实不用模拟，因为仔细想可以发现规律的存在。  
题目大意
共有 $4$ 根柱子，第四根柱子有 $N$ 个圆片，可以弹出某跟柱...","id":458381,"identifier":"solution-p1573","title":"P1573 栈的操作"},{"content":"和小粉兔吵了一架，小粉兔说是对的，那么小粉兔审这个题解的时候得给过。

参考资料：[知乎](https:\/\/www.zhihu.com\/question\/54353032\/answer\/294958858)

[论文](https:\/\/arxiv.org\/pdf\/1508.04272.pdf)

这里不赘述证明过程，只是作为一个转载告诉大家这个结论被证明了。

主要证明的有以下几个结论：

第一个：（详情见论文）一个叫做 Frame-Stewart algorithm 的柿子，令 $n$ 个盘，$p$ 个柱子，则这个算法的步数 $\Phi(p,n)$ 满足 $\Phi(p,n)=\min\limits_{1\le l现在有四个栈，其中前三个为空，第四个栈从栈顶到栈底分别为 $1,2,3,\cdots ,n$。每一个栈只支持一种操作：弹出并压入。它指的是把其中一个栈 $A$ 的栈顶元素 $x$ 弹出，并马上压入任意一个栈 $B$ 中。但是这样的操作必须符合一定的规则才能进行:
>>规则 $1$：$A$ 栈不能为空。  
>>规则 $2$：$B$ 栈为空或 $x$ 比 $B$ 栈栈顶要小。

但是最后要求的是：
>把第四个栈的 $n$ 个元素全部移到第一个栈的最少操作次数。

---
真是奇怪的题面，里面很多要求在常规的 **栈** 里面是不会出现的。我们把各个疑点罗列如下：

>每一个栈只支持一种操作：**弹出并压入**。它指的是把其中一个栈 $A$ 的栈顶元素 $x$ 弹出，**并马上** 压入任意一个栈 $B$ 中。

这一条提示我们：所有元素始终停留在这四个栈之中。

>规则 $2$：$B$ 栈 为空 或 $x$ 比 $B$ 栈栈顶要小。

而这一条乍一看很无厘头，但是结合 **栈** 的特性，及上一条的奇怪要求，我们可以发现，这玩意就是一个 **四柱汉诺塔**！前面的「其中前三个为空，第四个栈从栈顶到栈底分别为 $1,2,3,\cdots ,n$」，「求把第四个栈的 $n$ 个元素全部移到第一个栈的最少操作次数」也印证了我们的猜想。

---
于是我们只需要解决 **四柱汉诺塔** 问题即可。

设 $d_i$ 表示 $n$ 个盘的 **三柱汉诺塔** 的最少移动次数，显然有：

$d_i = \begin{cases}
1 & i=1 \\
d_{i-1} \times 2 + 1 & \operatorname{otherwise}\\
\end{cases}$

即把当前 $n-1$ 个盘从 $A$ 柱移动到 $B$ 柱，然后把第 $n$ 个盘从 $B$ 柱移动到 $C$ 柱。

回到本题，设 $f_i$ 表示 $n$ 个盘的 **四柱汉诺塔** 的最少移动次数，则：

$f_i = \begin{cases}
1 & i=1 \\
\min\limits_{1\leq i \lt n}(f_i\times2+d_{n-i}) & \operatorname{otherwise}\\
\end{cases}$

即先把 $i$ 个盘在四柱模式下从 $A$ 柱移动到 $B$ 柱，然后在三柱模式下把剩下 $(n-i)$ 个盘从 $A$ 柱移动到 $D$ 柱，最后再在在四柱模式下把 $B$ 柱上的 $i$ 个盘在四柱模式下从 $B$ 柱移动到 $D$ 柱。

这样我们可以很简单地得到实现代码，时间复杂度为 $\operatorname{O(}n^2\operatorname{)}$。

```cpp
#include
using namespace std;
const int maxn=65,mod=1e6+7;
int n,d[maxn],f[maxn];
inline int get_min(int a,int b){
	return a<b?a:b;
}
inline void di_tui(int tmp){
	d[tmp]=((d[tmp-1]+1)*2-1)%mod;
	for(int i=1;i<tmp;i++)
		f[tmp]=get_min(f[tmp],(f[i]*2+d[tmp-i])%mod);
	f[tmp]%=mod;
\/\/	printf("%d\n",f[tmp]);
	return;
}
int main(){
	scanf("%d",&n);
	memset(f,0x3f,sizeof(f));f[1]=1;
	for(int i=1;i<=n;i++) di_tui(i);
	printf("%d\n",f[n]);
	return 0;
}
```

再借助 [**这道题**](https:\/\/www.acwing.com\/problem\/content\/98\/)，这道题就可以愉快地结……，等等，数据范围不简单：

>对于 $30\%$ 的数据，$n\le 8$  
对于 $60\%$ 的数据，$n\le 60$  
对于 $100\%$ 的数据，$n\le 2\times 10^9$

这意味着，我们刚才 $\operatorname{O(}n^2\operatorname{)}$ 的算法并不能通过全部的测试点（实测 $60\ \text{pts}$）。

---
怎么办呢，根据经验，这个时候通常来说需要我们找到通项公式，于是我们输出几项来找找规律：
```
1,3,5,9,13,17,25,33,41,49,65,81,97,113,129,...
```
作差得到：
```
1,2,2,4,4,4,8,8,8,8,16,16,16,16,16,...
```
$2$ 的整次幂个数递增，于是我们把原数列排列成三角形得到：
```
[1]  1,
[2]  3,5,
[4]  9,13,17,
[8]  25,33,41,49,
[16] 65,81,97,113,129,
...
```
于是我们容易得到第 $i$ 行末尾元素的值 $val_i$ 的通项公式为：

$$
val_i=\sum\limits_{j=1}^ij\cdot2^{j-1}
$$

我们又知道第 $i$ 行末尾元素的编号 $pos_i$ 为:

$$
pos_i=\dfrac{i(i+1)}{2}
$$

所以有：

$$
\dfrac{i^2}{2}+\dfrac{i}{2}-pos_i=0
$$

所以在已知 $pos_i$ 时，它的上一行 $row(pos_i)$ 为：

$$
row(pos_i)=\left\lfloor -\dfrac{1}{2}+\sqrt{\dfrac{1}{4}+2\ pos_i}\right\rfloor+1
$$

再处理偏移量（即该元素是这一行的第几个） $dif(pos_i)$为:

$$
dif(pos_i)=pos_i-\dfrac{row(pos_i)\left(row(pos_i)-1\right)}{2}
$$

综合起来，最后第 $n$ 项的的答案 $ans$ 为：

$$
ans=dif(n)\times2^{row(n)}+\sum\limits_{i=1}^{row(n)}i\cdot2^{i-1}
$$

其中 $row(n)\approx\sqrt{n}$，即时间复杂度为 $\operatorname{O(}\sqrt{n}\operatorname{)}$，可以通过本题。

$\large\texttt{AC Code:}$
```cpp
#include
using namespace std;
const int mod=1e6+7;
long long n,row,dif,i,j,ans;
int main(){
	scanf("%lld",&n);
	row=(int)(-0.5+sqrt(0.25+2*(n-1)))+1;
	dif=n-row*(row-1)\/2;
	for(i=1,j=1;i<row;i++,j=(j*2)%mod) ans=(ans+i*j%mod)%mod;
	ans=(ans+dif*j%mod)%mod;
	printf("%d",ans%mod);
	return 0;
}
```
---
$\large\texttt{Tips:}$

记得取模，还要开`long long`。","type":"题解","status":2,"postTime":1670636999,"author":{"uid":567387,"name":"TG178X","slogan":"That's the way is.","badge":null,"isAdmin":false,"isBanned":false,"color":"Green","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/9yxv5qox.png"},"thumbUp":5,"commentCount":4,"currentUserVoteType":0,"contentDescription":"推荐使用 我的博客 打开，效果更好哦~

原题连接：P1573 栈的操作

让我们先来看一看题面描述：

现在有四个栈，其中前三个为空，第四个栈从栈顶到栈底分别为 $1,...","id":519232,"identifier":"solution-P1573","title":"P1573 栈的操作 题解"},{"content":"## 题目描述
有 $4$ 个栈，一开始有 $n$ 个数从小到大在 $4$ 号栈内，从顶至下分别是 $1,2,3,\cdots,n$，要求你将 $4$ 号栈里的 $n$ 个数通过一些规则移到 $1$ 号栈内，每一步可以将一个里面有数字的栈里的栈顶元素移到其他三个栈里面，**但是这个元素不能大于被移栈的栈顶，除非被移栈为空**，求最少步数。
## 分析
题目描述里加粗字体提示我们这是这一题解题的关键，栈的性质就是先进后出，也就是自顶向下取元素，那么，从上往下拿，小的叠在大的上面，我们想到了什么呢？对，汉诺塔！

一般的汉诺塔都是 $3$ 座塔的，但题目中有 $4$ 个栈，也就是 $4$ 座塔。我们可以手玩 $n \le 10$，不难发现当 $n$ 分别为 $1$ 至 $10$ 时，答案分别为 

```1 3 5 9 13 17 25 33 41 49```

设第 $i$ 步需要的步数为 $f_i$，我们求出它的差分数组 $b$，也就是 

```1 2 2 4 4 4 8 8 8 8```

其中 $f_0=0$，$b_i=f_i-f_{i-1}$，不难发现，$2^j$ 出现了 $j+1$ 次，为了验证答案，我们也可以将这个数列丢进 [OEIS](http:\/\/oeis.org\/)，以下是作者的查找记录：[记录](http:\/\/oeis.org\/search?q=1+3+5+9+13+17+25+33+41+49&language=english&go=Search)。
## 代码
知道了思路后，代码就很好写了，唯一需要注意的是要每步取模，以及要开 ```long long``` 。
```cpp
#include

using namespace std;

long long n,cnt=1,res=1,ans;\/\/cnt为有几项连续的res，res表示前一项与后一项的差，ans为最终答案。 
int main() {
	cin>>n;
	for(;cnt<=n;cnt++,res=res*2%1000007) n-=cnt,ans=(ans+cnt*res)%1000007;
	cout<<(ans+n*res)%1000007;\/\/由于可能有剩余的数，所以最后要加上。 
    return 0;
}
```
","type":"题解","status":2,"postTime":1672030740,"author":{"uid":670775,"name":"12345678hzx","slogan":"巅峰产生虚伪的拥护，黄昏见证虔诚的信徒。","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":4,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/5q69s72y.png"},"thumbUp":3,"commentCount":2,"currentUserVoteType":0,"contentDescription":"题目描述
有 $4$ 个栈，一开始有 $n$ 个数从小到大在 $4$ 号栈内，从顶至下分别是 $1,2,3,\cdots,n$，要求你将 $4$ 号栈里的 $n$ 个数通过一些规则移到 $1$ ...","id":524363,"identifier":"solution-p1573","title":"P1573题解"},{"content":"这题的数据有 $2×10^9$ 这么大，因此直接套用楼上的通项公式

$a_n = a + \sum\limits 2^{f(x)} = 1 - 2^{t-2} ( t^2 - 3t - 2n + 4)$

$t = g(\sqrt{2n})$

( $g(k)$ 指对 $k$ 四舍五入)

调用 `cmath` 库中的 `pow` 函数肯定会超过 `long long` 的范围，因此，需要自己定义一个乘方函数，每次计算都要取一次模，例如：

```cpp
long long f(long long n,long long m)
{
    long long a=1;

    for (int i=0;i<m;i++)
    {
        a*=n;
        a%=N;
    }

    return a;
}
```

剩下的就套用公式就好了！


这里贴一下代码
------------



```cpp
#include 
#include 
#include 
using namespace std;

const long long mod=1e6+7;

long long f(long long n,long long m)\/\/取模函数
{
    long long a=1;

    for (int i=0;i<m;i++)
    {
        a*=n;
        a%=mod;
    }

    return a;
}

int main()
{
    long long n;
    scanf("%lld",&n);\/\/输入

    long long t=round(sqrt(2*n));\/\/套用公式
    long long ans=round(1-f(2,t-2)*(t*t-3*t-2*n+4));

    printf("%lld",ans%mod);

    return 0;\/\/完结撒花！！！
}
```
","type":"题解","status":2,"postTime":1666405927,"author":{"uid":573704,"name":"cosmokramer","slogan":"一个CSP-j初赛只能得60分的屑","badge":null,"isAdmin":false,"isBanned":false,"color":"Blue","ccfLevel":0,"background":""},"thumbUp":3,"commentCount":0,"currentUserVoteType":0,"contentDescription":"这题的数据有 $2×10^9$ 这么大，因此直接套用楼上的通项公式
$a_n = a + \sum\limits 2^{f(x)} = 1 - 2^{t-2} ( t^2 - 3t - 2n +...","id":494621,"identifier":"solution-p1573","title":"P1573 栈的操作题解"},{"content":"[问题传送门](https:\/\/www.luogu.com.cn\/problem\/P1573)

**我理解的题意**

四阶汉诺塔的拓展。

**公式**

首先我们先把部分答案列出来。

```cpp
1 3 5 9 13 17 25 33 41 49 ...
```

看起来并没什么规律。但是我们可以试着将每个答案的差记录下来。

```cpp
1 2 2 4 4 4 8 8 8 8 16 16 16 16 16 ...
```

发现规律了吧。能明显 $1$ 出现 $1$ 次， $2$ 出现 $2$ 次， $4$ 出现 $3$ 次。列表如下。

```cpp
1 2 4 8 16 ...
1 2 3 4  5 ...
```

**AC Code:**

```cpp
#include 
#include 
using namespace std;
const int Mod = 1000007;

int main() {
	long long n;
	scanf("%lld",&n);
	long long i,j,ans = 0;
	for(i = 1 , j = 1; i <= n; ++i , j = (j * 2) % Mod) { \/\/ 公式
		n -= i;
		ans = (ans + i * j) % Mod;
	}
	printf("%lld",(ans + n * j) % Mod);
	return 0;
}

\/*1 2 2 4 4 4 8 8 8 8 16 16 16 16 16*\/
```

**p.s.不开 `long long` 见祖宗**
","type":"题解","status":2,"postTime":1681910279,"author":{"uid":757040,"name":"bj12z_dingbolin","slogan":"This is DBL.","badge":null,"isAdmin":false,"isBanned":false,"color":"Red","ccfLevel":0,"background":"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/ruehudw8.png"},"thumbUp":1,"commentCount":2,"currentUserVoteType":0,"contentDescription":"问题传送门
我理解的题意
四阶汉诺塔的拓展。
公式
首先我们先把部分答案列出来。

看起来并没什么规律。但是我们可以试着将每个答案的差记录下来。

发现规律了吧。能明显 $1$ 出现 $1$ 次...","id":566033,"identifier":"solution-p1573","title":"P1573 题解"}],"perPage":10,"count":6},"problem":{"pid":"P1573","title":"栈的操作","difficulty":0,"fullScore":100,"type":"P"},"acceptSolution":false},"currentTitle":"题解","currentTheme":{"id":559,"header":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-63,"degree":244,"repeat":0,"position":[50,17],"size":[1,1],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"},"sideNav":{"logoBackgroundColor":[23,208,180,1],"color":[255,64,122,1],"invertColor":false,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\SideNavConfig"},"footer":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-2,"degree":0,"repeat":0,"position":[38,73],"size":[0,0],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"}},"currentTime":1694599178,"currentUser":{"followingCount":0,"followerCount":0,"ranking":null,"eloValue":null,"blogAddress":null,"unreadMessageCount":0,"unreadNoticeCount":0,"uid":570994,"name":"kkRookie","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"","verified":true}}"));window._feConfigVersion=1694162564;window._tagVersion=1694594997;