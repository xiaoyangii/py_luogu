window._feInjection = JSON.parse(decodeURIComponent("{"code":200,"currentTemplate":"ProblemSolution","currentData":{"solutions":{"result":[{"content":"~~思维题，应该是黄到绿的题~~

### 情景类比

一个非常神奇的想法是具象化这个问题，把序列看成一列人，交换看成送礼物，最小值就是那个礼物，然后就可以愉快的模拟了。感性理解一下，会发现每次交换和其他数值无关，所以只考虑最小值的位置就可以了。

为方便描述，我们把第一个人称作队长，其他人为队员。比如样例，第三个队员有礼物（最小值）。他会在第二次交换把礼物交给第二个队员，然后第二个队员会在第三次交换把礼物交给队长。第一次交换与礼物无关。

### 从 CE-程序到 MIN-程序

由于给定交换序列不一定是 MIN-程序，所以先考虑把它变成 MIN-程序。即考虑如何增加交换，让队长总能收到任何一个队员的礼物。

令 $f_i$ 表示队员 $i$ 的状态，并给定以下两种状态：

- 若 $f_i=0$，说明任何初始情况下，队员 $i$ 不会扣下礼物。
- 若 $f_i=1$，说明存在初始情况下，队员 $i$ 会扣下礼物。

每个交换操作 $\text{CE(i,j)}$ 会修改 $f_i$ 和 $f_j$，转移方式按顺序如下：

- 如果 $f_j=0$ 那么 $f_i$ 不改变。（因为队员 $i$ 可能会扣下其他礼物）
- 如果 $f_j=1$ 那么令 $f_i=1$。（因为队员 $i$ 暂时扣下了队员 $j$ 给的礼物）
- 如果 $f_j=1$ 那么令 $f_j=0$。（因为队员 $j$ 暂时扣下的所有礼物都交给了队员 $i$）

模拟完毕后，让队长查一下谁会扣下礼物并~~教训这些逆子和~~统计答案。感性理解一下，就会发现这是最优的。

### 从 CE-程序到可靠的 MIN-程序

考虑删除 $\text{CE(i,j)}$ 的含义，我们就可以注意到队员 $j$ 扣下的礼物给出去的可能变小了。特别的，对于队员 $j$ 到手的礼物，我们至少需要跟进两个以上的与其他人的交换，好保证这礼物不会扣在自己手里。

令 $f_i$ 表示让队员 $i$ 不扣下礼物所需添加的最少交换次数，有以下三种可能：

- 若 $f_i=0$，说明任何交换删除和任何初始情况下，队员 $i$ 不会扣下礼物，所以不需要添加。
- 若 $f_i=1$，**在删除某个交换后**，存在某初始情况下，队员 $i$ 会被迫扣下礼物，没有删除交换时他并不会扣下礼物，所以只需要添加一个。
- 若 $f_i=2$，**不删除任何交换**，存在某初始情况下，队员 $i$ 会扣下礼物，所以需要添加两个，因为任何一个都可能被删除。

对于 $\text{CE(i,j)}$ 让队员 $j$ 交给队员 $i$ 礼物，那么必有 $f_i\ge f_j$。但因为这个交换会让队员 $j$ 单向影响队员 $i$，得到第一条转移。（无非两种情况，感性理解）

对于 $\text{CE(i,j)}$ 让队员 $j$ 交给队员 $i$ 礼物，那么让队员 $j$ 不扣下礼物所需添加的最少交换次数减一，得到第二条转移。所以得到以下两条转移。

- 令 $f_i=\max(f_i,f_j)$。这步必须优先。
- 若 $f_j>0$，令 $f_j=f_j-1$，队员 $j$ 下调状态。

实在不明白尝试理解下面拆分的情况。

- 如果 $f_j\le f_i$ 那么 $f_i$ 不改变。
- 如果 $f_j=1$ 且 $f_i=0$ 那么令 $f_i=1$。（队员 $i$ 本来不会扣下礼物，现在删除某个交换后，存在某情况让队员 $j$ 把扣下的礼物交给了队员 $i$）
- 如果 $f_j=2$ 且 $f_i<2$ 那么令 $f_i=2$。（无论如何，队员 $i$ 都会收到队员 $j$ 扣下的礼物）
- 如果 $f_j=1$ 那么令 $f_j=0$。（在删除某个交换后，某初始情况下，队员 $j$ 扣下的礼物交给了队员 $i$）
- 如果 $f_j=2$ 那么令 $f_j=1$。（在某初始情况下，队员 $j$ 扣下的礼物交给了队员 $i$，除非这个交换被删除）

模拟完毕后，让队长查一下谁会扣下礼物并~~继续教训这些逆子和~~统计答案，毕竟让队长督促总比队员互相监督更有效。最优来自于 $f_i$ 的定义。

### 参考代码

时空复杂度都是线性的，飞快。

```cpp
#include\/\/P2273 [HNOI2002] 交换
#include"custom_header\/fast_IO.h"
const int N=1e4+3;
int seq[N];
int main(){
	int n=read(),m=read(),ans=0,a,b;
	for(int i=2;i<=n;++i)seq[i]=2;
	for(int i=1;i<=m;++i){
		a=read(),b=read();
		if(a>1&&seq[a]<seq[b])seq[a]=seq[b];
		if(seq[b])--seq[b];
	}
	for(int i=1;i<=n;++i)ans+=seq[i];
	print(ans);
}
```","type":"题解","status":2,"postTime":1693687661,"author":{"uid":56489,"name":"一只小兔子","slogan":"只会压行的蒟蒻","badge":null,"isAdmin":false,"isBanned":false,"color":"Green","ccfLevel":0,"background":""},"thumbUp":1,"commentCount":0,"currentUserVoteType":0,"contentDescription":"思维题，应该是黄到绿的题
情景类比
一个非常神奇的想法是具象化这个问题，把序列看成一列人，交换看成送礼物，最小值就是那个礼物，然后就可以愉快的模拟了。感性理解一下，会发现每次交换和其他数值无关，...","id":629162,"identifier":"solution-p2273","title":"P2273 [HNOI2002] 交换 题解"}],"perPage":10,"count":1},"problem":{"pid":"P2273","title":"[HNOI2002] 交换","difficulty":0,"fullScore":100,"type":"P"},"acceptSolution":true},"currentTitle":"题解","currentTheme":{"id":559,"header":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-63,"degree":244,"repeat":0,"position":[50,17],"size":[1,1],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"},"sideNav":{"logoBackgroundColor":[23,208,180,1],"color":[255,64,122,1],"invertColor":false,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\SideNavConfig"},"footer":{"imagePath":"https:\/\/s2.ax1x.com\/2019\/08\/01\/ea5j4H.jpg","color":[[225,75,120,1],[23,208,180,1]],"blur":0,"brightness":-2,"degree":0,"repeat":0,"position":[38,73],"size":[0,0],"type":1,"__CLASS_NAME":"Luogu\DataClass\User\ThemeConfig\HeaderFooterConfig"}},"currentTime":1694599191,"currentUser":{"followingCount":0,"followerCount":0,"ranking":null,"eloValue":null,"blogAddress":null,"unreadMessageCount":0,"unreadNoticeCount":0,"uid":570994,"name":"kkRookie","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":"","verified":true}}"));window._feConfigVersion=1694162564;window._tagVersion=1694594997;